{
  "courseInfo": {
    "id": 4,
    "title": "JavaScript Alapok",
    "version": "1.0.0",
    "author": "Webfejlesztés Akadémia",
    "lastUpdated": "2024-01-15"
  },
  "pages": [
    {
      "id": 1,
      "title": "Mi a JavaScript?",
      "content": "A **JavaScript** egy dinamikus, interpretált programozási nyelv, amely a weboldalak interaktivitásáért felelős. Eredetileg csak böngészőkben futott, ma már szervereken (Node.js) és mobil alkalmazásokban is használható.\n\n**JavaScript jellemzői:**\n• Dinamikus típusok (nem kell előre deklarálni a változók típusát)\n• Interpretált nyelv (nem kell fordítani)\n• Objektum-orientált és funkcionális paradigmák\n• Event-driven (eseményvezérelt) programozás\n• Aszinkron programozás támogatása\n\nA JavaScript a web \"viselkedését\" határozza meg - minden interakció, animáció és dinamikus tartalom mögött JavaScript áll.",
      "image": "/images/js-intro.jpg",
      "codeExample": "// JavaScript alapok - első lépések\nconsole.log('Hello, JavaScript!');\n\n// Változók deklarálása\nlet message = 'Üdvözöl a JavaScript!';\nconst PI = 3.14159;\nvar oldStyle = 'régi stílus (kerüljük)';\n\n// Alapvető típusok\nlet number = 42;                    // szám\nlet string = 'szöveg';              // karakterlánc\nlet boolean = true;                 // logikai érték\nlet array = [1, 2, 3, 'négy'];      // tömb\nlet object = {                      // objektum\n    name: 'János',\n    age: 30,\n    isStudent: false\n};\nlet nothing = null;                 // null érték\nlet undefined_var;                  // undefined\n\n// Típus ellenőrzés\nconsole.log(typeof number);         // \"number\"\nconsole.log(typeof string);         // \"string\"\nconsole.log(typeof boolean);        // \"boolean\"\nconsole.log(typeof array);          // \"object\"\nconsole.log(typeof object);         // \"object\"",
      "keyPoints": [
        "JavaScript = dinamikus, interpretált programozási nyelv",
        "Böngészőben és szerveren is futtatható",
        "Event-driven és aszinkron programozás"
      ],
      "jsHistory": [
        {
          "year": "1995",
          "event": "Brendan Eich létrehozza a JavaScriptet (10 nap alatt!)"
        },
        {
          "year": "1997",
          "event": "ECMAScript szabvány létrehozása"
        },
        {
          "year": "2009",
          "event": "Node.js megjelenése (szerver oldali JS)"
        },
        {
          "year": "2015",
          "event": "ES6/ES2015 - modern JavaScript funkciók"
        },
        {
          "year": "2024",
          "event": "ES2024 - legújabb funkciók"
        }
      ]
    },
    {
      "id": 2,
      "title": "Változók és adattípusok",
      "content": "A JavaScript változók tárolják az adatokat. Három kulcsszóval deklarálhatunk változókat: `let`, `const`, és `var`. A modern JavaScriptben a `let` és `const` használata ajánlott.\n\n**Változó típusok:**\n• **let** - blokk szintű láthatóság, újradefiniálható\n• **const** - blokk szintű láthatóság, konstans érték\n• **var** - funkció szintű láthatóság (kerüljük)\n\n**Primitív típusok:** number, string, boolean, null, undefined, symbol, bigint\n**Összetett típusok:** object, array, function",
      "image": "/images/js-variables.jpg",
      "codeExample": "// Változó deklarációk és típusok\n\n// Számok (number)\nlet age = 25;\nlet price = 99.99;\nlet negative = -10;\nlet infinity = Infinity;\nlet notANumber = NaN;\n\n// Karakterláncok (string)\nlet firstName = 'Anna';\nlet lastName = \"Kovács\";\nlet fullName = `${firstName} ${lastName}`;  // template literal\nlet multiline = `Ez egy\nmehrsoros\nszöveg`;\n\n// Logikai értékek (boolean)\nlet isStudent = true;\nlet isWorking = false;\nlet canVote = age >= 18;  // kifejezés eredménye\n\n// Tömbök (array)\nlet numbers = [1, 2, 3, 4, 5];\nlet mixed = ['szöveg', 42, true, null];\nlet empty = [];\n\n// Objektumok (object)\nlet person = {\n    name: 'Péter',\n    age: 30,\n    city: 'Budapest',\n    hobbies: ['olvasás', 'sport'],\n    address: {\n        street: 'Fő utca 1.',\n        zipCode: 1011\n    }\n};\n\n// Speciális értékek\nlet nothing = null;        // szándékosan üres\nlet notDefined;           // undefined (nincs érték)\n\n// Típus konverziók\nlet stringNumber = '42';\nlet convertedNumber = Number(stringNumber);  // 42\nlet backToString = String(convertedNumber);  // '42'\nlet booleanValue = Boolean(0);               // false\n\n// Automatikus típus konverzió\nconsole.log('5' + 3);     // '53' (string concatenation)\nconsole.log('5' - 3);     // 2 (numeric subtraction)\nconsole.log('5' * 3);     // 15 (numeric multiplication)",
      "keyPoints": [
        "let és const használata ajánlott var helyett",
        "JavaScript dinamikus típusú nyelv",
        "Automatikus típus konverzió történhet"
      ],
      "variableComparison": [
        {
          "keyword": "var",
          "scope": "function",
          "hoisting": "yes",
          "redeclare": "yes",
          "recommendation": "kerüljük"
        },
        {
          "keyword": "let",
          "scope": "block",
          "hoisting": "no",
          "redeclare": "no",
          "recommendation": "használjuk"
        },
        {
          "keyword": "const",
          "scope": "block",
          "hoisting": "no",
          "redeclare": "no",
          "recommendation": "konstansokhoz"
        }
      ]
    },
    {
      "id": 3,
      "title": "Függvények",
      "content": "A függvények újrafelhasználható kódblokkok, amelyek egy adott feladatot hajtanak végre. A JavaScriptben többféle módon definiálhatunk függvényeket.\n\n**Függvény típusok:**\n• **Function Declaration** - hagyományos függvény deklaráció\n• **Function Expression** - függvény kifejezés\n• **Arrow Function** - nyíl függvény (ES6)\n• **Anonymous Function** - névtelen függvény\n\nA függvények paramétereket fogadhatnak és értéket visszaadhatnak.",
      "image": "/images/js-functions.jpg",
      "codeExample": "// Függvény deklarációk különböző módokon\n\n// 1. Hagyományos függvény deklaráció\nfunction greet(name) {\n    return `Szia, ${name}!`;\n}\n\n// 2. Függvény kifejezés\nconst add = function(a, b) {\n    return a + b;\n};\n\n// 3. Arrow function (nyíl függvény) - ES6\nconst multiply = (a, b) => a * b;\n\n// Arrow function több sorral\nconst calculateArea = (width, height) => {\n    const area = width * height;\n    return area;\n};\n\n// Egy paraméteres arrow function (zárójelek elhagyhatók)\nconst square = x => x * x;\n\n// Paraméter nélküli arrow function\nconst getCurrentTime = () => new Date().toLocaleTimeString();\n\n// Alapértelmezett paraméterek\nfunction introduce(name, age = 25, city = 'Budapest') {\n    return `Szia! ${name} vagyok, ${age} éves, ${city}-ből.`;\n}\n\n// Rest paraméterek (...)\nfunction sum(...numbers) {\n    return numbers.reduce((total, num) => total + num, 0);\n}\n\n// Függvény hívások\nconsole.log(greet('Anna'));                    // \"Szia, Anna!\"\nconsole.log(add(5, 3));                       // 8\nconsole.log(multiply(4, 7));                  // 28\nconsole.log(square(5));                       // 25\nconsole.log(introduce('Péter'));              // alapértelmezett értékekkel\nconsole.log(introduce('Mária', 30, 'Szeged')); // saját értékekkel\nconsole.log(sum(1, 2, 3, 4, 5));             // 15\n\n// Magasabb rendű függvények (függvény paraméterként)\nfunction processArray(arr, callback) {\n    return arr.map(callback);\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = processArray(numbers, x => x * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]",
      "keyPoints": [
        "Többféle függvény szintaxis létezik",
        "Arrow function rövidebb és lexikális this",
        "Függvények first-class objektumok JavaScriptben"
      ],
      "functionComparison": [
        {
          "type": "Function Declaration",
          "syntax": "function name() {}",
          "hoisting": "yes",
          "this": "dynamic"
        },
        {
          "type": "Function Expression",
          "syntax": "const name = function() {}",
          "hoisting": "no",
          "this": "dynamic"
        },
        {
          "type": "Arrow Function",
          "syntax": "const name = () => {}",
          "hoisting": "no",
          "this": "lexical"
        }
      ]
    },
    {
      "id": 4,
      "title": "DOM Manipuláció",
      "content": "A **DOM** (Document Object Model) a HTML dokumentum programozási interfészje. JavaScript segítségével dinamikusan módosíthatjuk a weboldal tartalmát, szerkezetét és stílusát.\n\n**DOM műveletek:**\n• Elemek kiválasztása\n• Tartalom módosítása\n• Attribútumok kezelése\n• Stílusok változtatása\n• Elemek hozzáadása/eltávolítása\n• Eseménykezelés\n\nA DOM manipuláció teszi lehetővé az interaktív weboldalak létrehozását.",
      "image": "/images/js-dom.jpg",
      "codeExample": "// DOM elemek kiválasztása\n\n// ID alapján\nconst header = document.getElementById('main-header');\n\n// CSS szelektor alapján (első találat)\nconst firstButton = document.querySelector('.btn');\nconst navLink = document.querySelector('nav a[href=\"#home\"]');\n\n// CSS szelektor alapján (összes találat)\nconst allButtons = document.querySelectorAll('.btn');\nconst allParagraphs = document.querySelectorAll('p');\n\n// Klasszikus módszerek\nconst byClass = document.getElementsByClassName('highlight');\nconst byTag = document.getElementsByTagName('p');\n\n// Tartalom módosítása\nheader.textContent = 'Új címsor szöveg';           // csak szöveg\nheader.innerHTML = '<span>HTML</span> tartalom';    // HTML is\n\n// Attribútumok kezelése\nconst image = document.querySelector('img');\nimage.src = 'new-image.jpg';\nimage.alt = 'Új kép leírás';\nimage.setAttribute('data-id', '123');\nconst imageId = image.getAttribute('data-id');\n\n// CSS osztályok kezelése\nconst element = document.querySelector('.box');\nelement.classList.add('active');           // osztály hozzáadása\nelement.classList.remove('hidden');        // osztály eltávolítása\nelement.classList.toggle('highlighted');   // osztály váltása\nelement.classList.contains('active');      // osztály ellenőrzése\n\n// Stílusok módosítása\nelement.style.backgroundColor = '#3498db';\nelement.style.padding = '20px';\nelement.style.borderRadius = '10px';\n\n// Új elemek létrehozása\nconst newParagraph = document.createElement('p');\nnewParagraph.textContent = 'Ez egy új bekezdés';\nnewParagraph.className = 'dynamic-content';\n\n// Elem hozzáadása a DOM-hoz\nconst container = document.querySelector('.container');\ncontainer.appendChild(newParagraph);\n\n// Elem beszúrása specifikus helyre\nconst referenceElement = document.querySelector('.reference');\ncontainer.insertBefore(newParagraph, referenceElement);\n\n// Elem eltávolítása\nconst elementToRemove = document.querySelector('.remove-me');\nelementToRemove.remove(); // modern módszer\n// vagy: elementToRemove.parentNode.removeChild(elementToRemove);\n\n// Eseménykezelés\nconst button = document.querySelector('#my-button');\n\n// Esemény hozzáadása\nbutton.addEventListener('click', function(event) {\n    console.log('Gombra kattintottak!');\n    event.preventDefault(); // alapértelmezett viselkedés megakadályozása\n});\n\n// Arrow function eseménykezelővel\nbutton.addEventListener('mouseover', (e) => {\n    e.target.style.backgroundColor = '#e74c3c';\n});\n\n// Több esemény kezelése\nconst input = document.querySelector('#my-input');\ninput.addEventListener('input', (e) => {\n    console.log('Beviteli mező értéke:', e.target.value);\n});\n\n// Esemény eltávolítása\nconst handleClick = () => console.log('Gomb kattintás!');\nbutton.addEventListener('click', handleClick);\nbutton.removeEventListener('click', handleClick);",
      "keyPoints": [
        "DOM = HTML dokumentum objektum modellje",
        "Elemek kiválasztása és manipulálása",
        "Események kezelése interaktív funkciókhoz"
      ]
    },
    {
  "id": 5,
  "title": "Eseménykezelés JavaScript-ben",
  "content": "Az eseménykezelés a JavaScript egyik alapvető része, amely lehetővé teszi, hogy a weboldal interaktív legyen és reagáljon a felhasználói műveletekre.\n\n---\n\n## 1. Mi az esemény?\n\nAz esemény egy adott történés a böngészőben vagy a felhasználó részéről, például kattintás, billentyűleütés, egérmozgás, űrlap elküldése stb.\n\n## 2. Eseménykezelő hozzáadása\n\n### 2.1 Inline eseménykezelő HTML-ben\n\n```html\n<button onclick=\"alert('Kattintottál!')\">Kattints rám!</button>\n```\nEz egyszerű, de nem ajánlott nagyobb alkalmazásokban.\n\n### 2.2 JavaScript-ben – eseménykezelő függvény hozzárendelése\n\n```js\nconst button = document.querySelector('button');\nbutton.onclick = function() {\n  alert('Kattintottál!');\n};\n```\nEz felülírja a korábbi eseménykezelőt, ha volt.\n\n### 2.3 addEventListener használata (ajánlott)\n\n```js\nconst button = document.querySelector('button');\nbutton.addEventListener('click', function() {\n  alert('Kattintottál!');\n});\n```\nLehetővé teszi több eseménykezelő hozzárendelését ugyanahhoz az eseményhez.\n\n## 3. Esemény típusok\n\nNéhány gyakori eseménytípus:\n\n- `click`: kattintás\n- `dblclick`: dupla kattintás\n- `mouseover`: egérmutató ráhúzása\n- `mouseout`: egérmutató elhagyása\n- `keydown`, `keyup`: billentyűleütés\n- `submit`: űrlap elküldése\n- `load`: oldal vagy kép betöltése\n\n## 4. Az esemény objektum (event)\n\nAz eseménykezelő függvény első paramétere egy esemény objektum, amely részletes információkat tartalmaz az eseményről.\n\n```js\nbutton.addEventListener('click', function(event) {\n  console.log('Esemény típusa:', event.type);\n  console.log('Az esemény célja:', event.target);\n});\n```\n\n## 5. Esemény buborékolás és megállítása\n\nAz események alapértelmezett módon buborékolnak (feljebb terjednek a DOM-ban). Ezt megállíthatjuk:\n\n- `event.stopPropagation()` – megállítja a további buborékolást\n- `event.preventDefault()` – megakadályozza az alapértelmezett viselkedést (pl. link navigáció, űrlap elküldés)\n\n## 6. Esemény delegálás\n\nAz esemény delegálás technika, ahol egy szülőelemhez kötünk eseménykezelőt, és onnan kezeljük a gyerek elemek eseményeit. Ez hatékonyabb, ha sok hasonló elemünk van.\n\n```js\nconst lista = document.querySelector('ul');\nlista.addEventListener('click', function(event) {\n  if (event.target.tagName === 'LI') {\n    alert('Kattintottál egy listaelemre: ' + event.target.textContent);\n  }\n});\n```\n\n## 7. Gyakori példa: gomb kattintás kezelése\n\n```html\n<button id=\"myBtn\">Kattints rám!</button>\n<script>\n  const btn = document.getElementById('myBtn');\n  btn.addEventListener('click', () => {\n    alert('Gomb megnyomva!');\n  });\n</script>\n```\n\n---\n\n## Összefoglalás\n\n- Az események teszik interaktívvá a weboldalt.\n- Az eseménykezelők hozzárendelése az `addEventListener` segítségével a legjobb gyakorlat.\n- Az esemény objektum segítségével információkat kapunk az eseményről.\n- Esemény buborékolás kezelhető és megállítható.\n- Esemény delegálás hatékony módja sok hasonló elem kezelése esetén.\n\n---\n\n## Hasznos eszközök és dokumentáció\n\n- [MDN Event reference](https://developer.mozilla.org/en-US/docs/Web/Events)\n- Böngészők fejlesztői eszközei (Console, Event Listeners tab)\n\n",
  "keyPoints": [
    "Az eseménykezelés lehetővé teszi a felhasználói interakciók kezelését.",
    "Az addEventListener a legjobb módja eseménykezelő hozzáadásának.",
    "Az esemény objektum információkat ad az eseményről.",
    "Esemény buborékolás megállítható stopPropagation()-nal.",
    "Esemény delegálással hatékonyabban kezelhetünk sok elemet."
  ]
},
{
  "id": 6,
  "title": "Feltételek és ciklusok JavaScript-ben",
  "content": "A feltételek és ciklusok alapvető vezérlési szerkezetek a JavaScript-ben, amelyek segítségével döntéseket hozhatunk és ismétlődő műveleteket végezhetünk.\n\n---\n\n## 1. Feltételek (if, else, else if)\n\nA feltételek lehetővé teszik, hogy a program bizonyos kódrészeket csak akkor hajtson végre, ha egy adott feltétel igaz.\n\n```js\nconst age = 18;\nif (age >= 18) {\n  console.log('Beléphetsz a weboldalra.');\n} else {\n  console.log('Nem vagy még nagykorú.');\n}\n```\n\n### Több feltétel ellenőrzése\n\n```js\nconst score = 75;\nif (score >= 90) {\n  console.log('Kitűnő');\n} else if (score >= 60) {\n  console.log('Jó');\n} else {\n  console.log('Javítás szükséges');\n}\n```\n\n## 2. Logikai operátorok\n\nFeltételek összekapcsolása:\n\n- `&&` — és (AND)\n- `||` — vagy (OR)\n- `!` — nem (NOT)\n\n```js\nconst isAdult = true;\nconst hasID = false;\nif (isAdult && hasID) {\n  console.log('Belépés engedélyezve');\n} else {\n  console.log('Belépés megtagadva');\n}\n```\n\n## 3. Switch szerkezet\n\nAlternatív mód több feltétel ellenőrzésére:\n\n```js\nconst fruit = 'alma';\nswitch (fruit) {\n  case 'alma':\n    console.log('Ez egy alma.');\n    break;\n  case 'banán':\n    console.log('Ez egy banán.');\n    break;\n  default:\n    console.log('Ismeretlen gyümölcs');\n}\n```\n\n## 4. Ciklusok\n\n### 4.1 For ciklus\n\nIsmétlődő műveletek előre ismert számú alkalommal.\n\n```js\nfor (let i = 0; i < 5; i++) {\n  console.log('Szám:', i);\n}\n```\n\n### 4.2 While ciklus\n\nAddig fut, amíg a feltétel igaz.\n\n```js\nlet i = 0;\nwhile (i < 5) {\n  console.log('Szám:', i);\n  i++;\n}\n```\n\n### 4.3 Do-while ciklus\n\nLegalább egyszer lefut, majd ellenőrzi a feltételt.\n\n```js\ni = 0;\ndo {\n  console.log('Szám:', i);\n  i++;\n} while (i < 5);\n```\n\n## 5. Ciklus megszakítása\n\n- `break`: kilép a ciklusból\n- `continue`: kihagyja az aktuális iterációt, és a következőre lép\n\n```js\nfor (let i = 0; i < 10; i++) {\n  if (i === 5) break; // Kilép 5-nél\n  if (i % 2 === 0) continue; // Kihagyja a páros számokat\n  console.log(i); // Csak páratlan számok 5 előtt\n}\n```\n\n---\n\n## Összefoglalás\n\n- Feltételekkel irányítjuk a program áramlását.\n- Ciklusok segítségével ismétlődő műveleteket hajthatunk végre.\n- Logikai operátorokkal összetett feltételeket alkothatunk.\n- Switch egyszerűbbé teszi a többágú döntést.\n- `break` és `continue` cikluskezelő utasítások.\n\n---\n\n## Hasznos eszközök\n\n- Böngésző konzol (Console) gyors teszteléshez\n- MDN JavaScript Control flow\n\n",
  "keyPoints": [
    "Feltételek segítségével döntéseket hozunk a kódban.",
    "Ciklusokkal ismétlődő feladatokat végezhetünk el.",
    "Logikai operátorokkal összetett feltételeket alkothatunk.",
    "Switch szerkezet alternatív a többágú döntésekhez.",
    "Break és continue segít a ciklusok vezérlésében."
  ]
},
{
  "id": 7,
  "title": "Objektumok és tömbök kezelése JavaScript-ben",
  "content": "Az objektumok és tömbök a JavaScript alapvető adattípusai, melyek segítségével strukturált adatokat kezelhetünk.\n\n---\n\n## 1. Objektumok\n\nAz objektumok kulcs-érték párokat tartalmaznak, ahol a kulcs string vagy szimbólum, az érték pedig tetszőleges adat lehet.\n\n```js\nconst person = {\n  name: 'János',\n  age: 30,\n  isStudent: false\n};\n\nconsole.log(person.name); // János\nconsole.log(person['age']); // 30\n```\n\n### Tulajdonságok módosítása, hozzáadása, törlése\n\n```js\nperson.age = 31; // módosítás\nperson.city = 'Budapest'; // hozzáadás\ndelete person.isStudent; // törlés\n```\n\n## 2. Tömbök\n\nA tömbök rendezett elemek gyűjteményei, indexük 0-tól kezdődik.\n\n```js\nconst fruits = ['alma', 'banán', 'narancs'];\nconsole.log(fruits[1]); // banán\n```\n\n### Tömb műveletek\n\n- Hozzáadás: `push`, `unshift`\n- Eltávolítás: `pop`, `shift`\n- Iterálás: `for`, `forEach`\n\n```js\nfruits.push('eper'); // hozzáad az utolsó helyre\nfruits.pop(); // eltávolít az utolsó helyről\nfruits.forEach(fruit => console.log(fruit));\n```\n\n## 3. Objektum és tömb kombináció\n\nGyakran találkozunk tömbökbe rendezett objektumokkal, pl. felhasználói adatok:\n\n```js\nconst users = [\n  { id: 1, name: 'Anna' },\n  { id: 2, name: 'Béla' }\n];\n\nusers.forEach(user => console.log(user.name));\n```\n\n## 4. Objektum és tömb destrukturálás\n\nEgyszerűsíti az értékek kinyerését.\n\n```js\nconst { name, age } = person;\nconst [firstFruit, secondFruit] = fruits;\nconsole.log(name, age);\nconsole.log(firstFruit, secondFruit);\n```\n\n---\n\n## Összefoglalás\n\n- Objektumok kulcs-érték párok, tömbök rendezett elemek.\n- Mindkettő fontos adatszerkezet a JavaScript-ben.\n- Tömbök és objektumok kombinációja gyakori a gyakorlatban.\n- Destrukturálással egyszerűbb az adatok elérése.\n\n---\n\n## Hasznos eszközök\n\n- Böngésző konzol az adatok teszteléséhez\n- MDN Object és Array dokumentáció\n",
  "keyPoints": [
    "Objektumok kulcs-érték párokból állnak.",
    "Tömbök rendezett elemek sorozata.",
    "Tömbök és objektumok gyakran kombinálódnak.",
    "Destrukturálással könnyebben hozzáférünk az értékekhez.",
    "Fontos alapvető adatszerkezetek JavaScript-ben."
  ]
},
{
  "id": 8,
  "title": "Függvények mélyebben – visszatérés, paraméterek és scope",
  "content": "Ebben a leckében mélyebben megismerkedünk a függvények visszatérésével, paramétereivel és a változók láthatóságával (scope).\n\n---\n\n## 1. Visszatérés több értékkel\n\nBár a `return` csak egyszer tud visszatérni, objektummal vagy tömbbel több értéket is visszaadhatunk.\n\n```js\nfunction getCoordinates() {\n  return { x: 10, y: 20 };\n}\n\nconst coords = getCoordinates();\nconsole.log(coords.x, coords.y); // 10 20\n```\n\n---\n\n## 2. Paraméterek alapjai\n\nA függvények bemeneti adatait paraméterek segítségével kapják meg.\n\n```js\nfunction koszones(nev) {\n  return `Szia, ${nev}!`;\n}\n\nconsole.log(koszones('Anna')); // Szia, Anna!\n```\n\n### Alapértelmezett paraméterek\n\nHa nem adunk meg argumentumot, akkor használhatunk alapértelmezett értékeket:\n\n```js\nfunction koszones(nev = 'Vendég') {\n  return `Szia, ${nev}!`;\n}\n\nconsole.log(koszones()); // Szia, Vendég!\n```\n\n---\n\n## 3. Scope – változók láthatósága\n\nA változók élettartama és láthatósága függ attól, hogy hol vannak deklarálva.\n\n### Globális scope\n\nHa egy változót a függvényen kívül definiálunk, az elérhető a teljes scriptben.\n\n```js\nlet globalVal = 5;\nfunction showGlobal() {\n  console.log(globalVal); // 5\n}\nshowGlobal();\n```\n\n### Lokális scope\n\nHa egy változót egy függvényben deklarálunk, az csak ott elérhető.\n\n```js\nfunction test() {\n  let localVal = 10;\n  console.log(localVal); // 10\n}\n\n// console.log(localVal); // Hibát okoz, mert nincs globálisan\n```\n\n---\n\n## 4. Paraméter és változó név ütközése\n\nHa egy paraméter neve megegyezik egy globális változó nevével, a függvényen belül a paraméter értéke lesz az elsődleges.\n\n```js\nlet nev = 'Világ';\nfunction koszones(nev) {\n  return `Szia, ${nev}!`;\n}\nconsole.log(koszones('Anna')); // Szia, Anna!\nconsole.log(nev); // Világ\n```\n\n---\n\n## 5. Closure alapok (bevezetés)\n\nFüggvények belső függvényeket hozhatnak létre, amelyek hozzáférnek a külső függvény változóihoz.\n\n```js\nfunction szamlalo() {\n  let count = 0;\n  return function() {\n    count++;\n    return count;\n  };\n}\n\nconst countFunc = szamlalo();\nconsole.log(countFunc()); // 1\nconsole.log(countFunc()); // 2\n```\n\n---\n\n## Összefoglalás\n\n- A függvények paraméterekkel kapják meg a bemeneti adatokat.\n- A `return` objektumok vagy tömbök formájában több értéket is visszaadhat.\n- A változók láthatósága (scope) lehet globális vagy lokális.\n- Paraméterek felülírhatják a globális változókat a függvényen belül.\n- A closure lehetővé teszi, hogy belső függvények hozzáférjenek a külső függvény változóihoz.\n\n---\n\n## Hasznos eszközök\n\n- Böngésző konzol és debugger\n- MDN JavaScript dokumentáció\n",
  "keyPoints": [
    "Függvények paramétereket kapnak bemeneti adatként.",
    "`return` objektummal vagy tömbbel több értéket adhat vissza.",
    "A változók scope-ja lehet globális vagy lokális.",
    "Paraméterek felülírhatják a globális változókat függvényen belül.",
    "Closure-ök lehetővé teszik belső függvények számára a külső változók elérését."
  ]
},
{
  "id": 9,
  "title": "Aszinkron JavaScript alapok – callbackek és Promise-ok",
  "content": "Ebben a leckében megismerkedünk az aszinkron JavaScript alapjaival, különösen a callback függvényekkel és a Promise-okkal.\n\n---\n\n## 1. Mi az aszinkron művelet?\n\nAz aszinkron művelet lehetővé teszi, hogy a program más feladatokat is végezzen, miközben egy hosszabb ideig tartó művelet (pl. adatlekérés) folyamatban van.\n\n## 2. Callback függvények\n\nA callback egy olyan függvény, amit egy másik függvénynek adunk át, és azt akkor hívják meg, amikor a művelet befejeződik.\n\n```js\nfunction letoltes(url, callback) {\n  setTimeout(() => {\n    console.log(`Adatok letöltve innen: ${url}`);\n    callback('adatok');\n  }, 2000);\n}\n\nletoltes('https://pelda.hu', function(adatok) {\n  console.log('Feldolgozás:', adatok);\n});\n```\n\n## 3. Callback Hell (callback pokol)\n\nTöbb egymásba ágyazott callback nehezen olvasható és karbantartható kódot eredményez.\n\n```js\nfeladat1(() => {\n  feladat2(() => {\n    feladat3(() => {\n      console.log('Kész!');\n    });\n  });\n});\n```\n\n## 4. Promise alapok\n\nA Promise egy objektum, ami egy jövőbeni eredményt képvisel.\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => resolve('Sikeres adat!'), 2000);\n});\n\npromise.then(result => {\n  console.log(result);\n});\n```\n\n## 5. Promise állapotai\n\n- **Pending:** függőben lévő művelet\n- **Fulfilled:** sikeres befejezés\n- **Rejected:** hibás befejezés\n\n## 6. Promise láncolás\n\nEgymás után több Promise is kezelhető így:\n\n```js\nlet promise = new Promise(resolve => {\n  setTimeout(() => resolve(1), 1000);\n});\n\npromise\n  .then(result => {\n    console.log(result); // 1\n    return result * 2;\n  })\n  .then(result => {\n    console.log(result); // 2\n  });\n```\n\n## 7. Async/Await bevezetés\n\nAz `async` és `await` használatával szinkronhoz hasonló, könnyen olvasható aszinkron kódot írhatunk.\n\n```js\nasync function letoltes() {\n  let adat = await new Promise(resolve => setTimeout(() => resolve('Adat készen'), 2000));\n  console.log(adat);\n}\n\nletoltes();\n```\n\n---\n\n## Összefoglalás\n\n- Aszinkron műveletek nem blokkolják a fő szálat.\n- Callbackek a korai aszinkron kezelés eszközei.\n- Promise-ok strukturáltabb aszinkron kezelést tesznek lehetővé.\n- Async/Await a Promise-ok egyszerűbb használatát biztosítja.\n\n---\n\n## Hasznos eszközök\n\n- Böngésző fejlesztői eszközök hálózati fül\n- MDN dokumentáció: Promise, Async/Await\n",
  "keyPoints": [
    "Az aszinkron JavaScript nem blokkolja a futást hosszú műveletek alatt.",
    "A callback függvények akkor futnak le, amikor a művelet befejeződik.",
    "A Promise egy jövőbeni értéket képviselő objektum.",
    "A Promise láncolható `then` metódusokkal.",
    "Az async/await egyszerűbbé és olvashatóbbá teszi az aszinkron kódot."
  ]
},
{
  "id": 10,
  "title": "Modern JavaScript – ES6+ újdonságok (let, const, arrow function)",
  "content": "Ebben a leckében megismerkedünk a modern JavaScript (ES6 és újabb) legfontosabb újdonságaival, mint a `let`, `const` és az arrow function (nyílfüggvény).\n\n---\n\n## 1. let és const\n\n### let\nA `let` változóblokkszintű (block scoped), vagyis csak a legközelebbi blokkban elérhető, ahol definiálták.\n\n```js\nif (true) {\n  let x = 10;\n  console.log(x); // 10\n}\n// console.log(x); // hibát dob, mert x nem elérhető itt\n```\n\n### const\nA `const` változó konstans, azaz nem lehet újra hozzárendelni az értékét. Blokkszintű, mint a `let`.\n\n```js\nconst y = 5;\n// y = 10; // hibát dob\n```\n\nMegjegyzés: `const` esetén az objektum vagy tömb elemei módosíthatók, de a referencia nem változtatható meg.\n\n---\n\n## 2. Arrow function (nyílfüggvény)\n\nAz arrow function egy rövidített szintaxisú függvényírási mód, amely nem rendelkezik saját `this` kontextussal.\n\n```js\n// Hagyományos függvény\nfunction osszeg(a, b) {\n  return a + b;\n}\n\n// Arrow function\nconst osszeg2 = (a, b) => a + b;\n\nconsole.log(osszeg2(2, 3)); // 5\n```\n\nHa csak egy paraméter van, a zárójelek elhagyhatók:\n\n```js\nconst negyzet = x => x * x;\n```\n\nHa több utasításból áll a függvény, akkor kapcsos zárójeleket és explicit `return`-t kell használni:\n\n```js\nconst osszeg3 = (a, b) => {\n  const eredmeny = a + b;\n  return eredmeny;\n};\n```\n\n---\n\n## 3. Miért használjuk az ES6+ újításokat?\n\n- Tisztább, áttekinthetőbb kód.\n- Jobb változókezelés a `let` és `const` miatt.\n- Egyszerűbb függvényírás arrow function-nal.\n- Az ES6+ szintaxis a modern böngészőkben és környezetekben alapértelmezett.\n\n---\n\n## Összefoglalás\n\n- `let` és `const` blokkszintű változókat hoznak létre.\n- `const` értéke nem módosítható új hozzárendeléssel.\n- Arrow function rövid, tiszta függvényírást biztosít.\n- Az ES6+ funkciók növelik a kód minőségét és karbantarthatóságát.\n\n---\n\n## Példa kód\n\n```js\nconst nevek = ['Anna', 'Béla', 'Cecil'];\n\nconst nagybetusNevek = nevek.map(név => név.toUpperCase());\nconsole.log(nagybetusNevek); // ['ANNA', 'BÉLA', 'CECIL']\n```\n\n---\n\n## Hasznos linkek\n\n- MDN `let`: https://developer.mozilla.org/hu/docs/Web/JavaScript/Reference/Statements/let\n- MDN `const`: https://developer.mozilla.org/hu/docs/Web/JavaScript/Reference/Statements/const\n- MDN Arrow function: https://developer.mozilla.org/hu/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n",
  "keyPoints": [
    "`let` és `const` blokkszintű változókat definiál.",
    "`const` értéke nem módosítható új hozzárendeléssel.",
    "Arrow function rövidebb és egyszerűbb függvényírást tesz lehetővé.",
    "Arrow function nem rendelkezik saját `this` kontextussal.",
    "Az ES6+ újítások modern, tiszta kódot eredményeznek."
  ]
},
{
  "id": 11,
  "title": "Moduláris JavaScript – import/export használata",
  "content": "Ebben a leckében megismerkedünk a JavaScript modulrendszerével, amely lehetővé teszi a kód részek szétválasztását és újrafelhasználását.\n\n---\n\n## 1. Mi az a moduláris JavaScript?\n\nA moduláris JavaScript lehetővé teszi, hogy a kódot kisebb, jól elkülöníthető részekre (modulokra) bontsuk, amelyeket külön fájlokban kezelünk és szükség szerint importálunk.\n\n---\n\n## 2. Exportálás\n\nEgy modulból exportálhatunk változókat, függvényeket vagy osztályokat.\n\n### Named export (név szerinti export):\n\n```js\n// math.js\nexport function osszeg(a, b) {\n  return a + b;\n}\n\nexport const PI = 3.14;\n```\n\n### Default export (alapértelmezett export):\n\n```js\n// greet.js\nexport default function köszönés(név) {\n  return `Szia, ${név}!`;\n}\n```\n\n---\n\n## 3. Importálás\n\n### Named import:\n\n```js\nimport { osszeg, PI } from './math.js';\nconsole.log(osszeg(2, 3)); // 5\nconsole.log(PI); // 3.14\n```\n\n### Default import:\n\n```js\nimport köszönés from './greet.js';\nconsole.log(köszönés('Anna')); // Szia, Anna!\n```\n\n---\n\n## 4. Vegyes importálás\n\nLehet egyszerre named és default importot is használni:\n\n```js\nimport köszönés, { extraFüggvény } from './greet.js';\n```\n\n---\n\n## 5. Miért használjunk modulokat?\n\n- Kód átláthatósága és újrafelhasználhatósága.\n- Jobb hibakeresés.\n- Egyértelmű függőségkezelés.\n- Nagy projektek esetén kötelező gyakorlat.\n\n---\n\n## 6. Fontos tudnivalók\n\n- A modulokat általában `.js` vagy `.mjs` kiterjesztéssel mentjük.\n- A böngészőben a `<script type=\"module\">` attribútummal lehet használni modulokat.\n- Node.js-ben alapértelmezésben az `import/export` használatához a projektnek `type: \"module\"` legyen a `package.json`-ban.\n\n---\n\n## Összefoglalás\n\n- A moduláris JavaScript segítségével kódunk kisebb, kezelhető részekre bomlik.\n- `export` segítségével elérhetővé tesszük a modul elemeit.\n- `import`-tal más modulokból használhatjuk ezeket.\n- Named és default export/import lehetőségek.\n\n---\n\n## Példa kód\n\n```js\n// math.js\nexport function szorzas(a, b) {\n  return a * b;\n}\n\n// main.js\nimport { szorzas } from './math.js';\nconsole.log(szorzas(3, 4)); // 12\n```\n\n---\n\n## Hasznos linkek\n\n- MDN Modules: https://developer.mozilla.org/hu/docs/Web/JavaScript/Guide/Modules\n- Node.js Modules: https://nodejs.org/api/modules.html\n",
  "keyPoints": [
    "A moduláris JavaScript segít a kód részekre bontásában.",
    "`export` kulcsszóval elérhetővé tesszük a modul elemeit.",
    "`import`-tal más modulokból használhatjuk az exportált elemeket.",
    "Két típusú export/import létezik: named és default.",
    "A modulok használata átláthatóbb és karbantarthatóbb kódot eredményez."
  ]
},
{
  "id": 12,
  "title": "Fetch API és HTTP kérések kezelése",
  "content": "Ebben a leckében megismerkedünk a Fetch API-val, amely a modern böngészőkben elérhető beépített eszköz HTTP kérések indítására és kezelésére JavaScriptből.\n\n---\n\n## 1. Mi az a Fetch API?\n\nA Fetch API egy egyszerű és rugalmas módja az aszinkron HTTP kérések indításának, amely Promise alapú, így könnyen kezelhető a válasz és a hibák.\n\n---\n\n## 2. Alapvető használat\n\n```js\nfetch('https://jsonplaceholder.typicode.com/posts/1')\n  .then(response => {\n    if (!response.ok) {\n      throw new Error('Hálózati hiba: ' + response.status);\n    }\n    return response.json();\n  })\n  .then(data => {\n    console.log(data);\n  })\n  .catch(error => {\n    console.error('Hiba történt:', error);\n  });\n```\n\n---\n\n## 3. Request konfiguráció\n\nFetch alapból GET kérést küld, de lehet POST, PUT, DELETE is, plusz beállíthatók fejlécek, test (body), stb.\n\n```js\nfetch('https://api.example.com/data', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    name: 'Anna',\n    age: 25\n  })\n})\n.then(response => response.json())\n.then(data => console.log(data));\n```\n\n---\n\n## 4. Async/await szintaxis\n\nModern módon az async/await segítségével egyszerűbb a kód:\n\n```js\nasync function getData() {\n  try {\n    const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');\n    if (!response.ok) {\n      throw new Error('Hiba a hálózaton: ' + response.status);\n    }\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Hiba:', error);\n  }\n}\n\ngetData();\n```\n\n---\n\n## 5. Hibakezelés\n\nFontos kezelni a HTTP státuszokat és a hálózati hibákat is, mert nem minden nem sikeres válasz dob hibát automatikusan.\n\n---\n\n## 6. CORS (Cross-Origin Resource Sharing)\n\nA Fetch API használata esetén figyelni kell a CORS szabályokra, mert a böngészők csak megfelelő engedéllyel engedik más domainekről érkező kéréseket.\n\n---\n\n## Összefoglalás\n\n- A Fetch API egy modern, Promise-alapú eszköz HTTP kérésekhez.\n- Alapból GET kérést küld, de más HTTP metódusok is használhatók.\n- Használható async/await-tel a kód egyszerűsítésére.\n- Fontos a hibakezelés és a CORS szabályok ismerete.\n\n---\n\n## Példa kód\n\n```js\n// GET kérés\nfetch('https://api.example.com/users')\n  .then(res => res.json())\n  .then(data => console.log(data))\n  .catch(err => console.error(err));\n\n// POST kérés\nfetch('https://api.example.com/users', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ name: 'Kata' })\n})\n.then(res => res.json())\n.then(data => console.log(data));\n```\n",
  "keyPoints": [
    "Fetch API Promise alapú HTTP kéréskezelő.",
    "Alapértelmezett metódus: GET, de lehet POST, PUT, DELETE stb.",
    "Async/await szintaxissal egyszerűbb a használata.",
    "Fontos a HTTP státuszok és hibák kezelése.",
    "CORS szabályokat figyelembe kell venni más domain esetén."
  ]
},
{
  "id": 13,
  "title": "JSON feldolgozás és kommunikáció backenddel",
  "content": "Ebben a leckében megismerkedünk a JSON (JavaScript Object Notation) használatával adatátvitelhez frontend és backend között.\n\n---\n\n## 1. Mi az a JSON?\n\nA JSON egy könnyen olvasható és írható adatcsere-formátum, amelyet gyakran használnak webes alkalmazások adatainak átvitelére.\n\n---\n\n## 2. JSON konvertálás JavaScriptben\n\n- Objektumból JSON stringet készítünk a `JSON.stringify()` metódussal.\n- JSON stringből JavaScript objektumot hozunk létre a `JSON.parse()` metódussal.\n\n```js\nconst obj = { name: 'Péter', age: 30 };\nconst jsonStr = JSON.stringify(obj);\nconsole.log(jsonStr); // '{\"name\":\"Péter\",\"age\":30}'\n\nconst parsedObj = JSON.parse(jsonStr);\nconsole.log(parsedObj.name); // 'Péter'\n```\n\n---\n\n## 3. Kommunikáció backenddel Fetch API-val\n\nGyakran JSON formátumban küldjük és fogadjuk az adatokat a szerverrel.\n\n### Példa POST kérés JSON adattal:\n\n```js\nfetch('https://api.example.com/users', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({ username: 'anna', password: '1234' })\n})\n.then(response => response.json())\n.then(data => console.log('Siker:', data))\n.catch(error => console.error('Hiba:', error));\n```\n\n### Példa JSON válasz kezelése:\n\n```js\nfetch('https://api.example.com/users/1')\n  .then(response => response.json())\n  .then(user => console.log(user.name))\n  .catch(error => console.error('Hiba:', error));\n```\n\n---\n\n## 4. Hibakezelés és validáció\n\nMindig ellenőrizzük a szerver válaszát és kezeljük a hibákat. A backend is validálja az adatokat, a frontend pedig biztosíthatja a helyes formátumot.\n\n---\n\n## 5. Összefoglalás\n\n- A JSON a legelterjedtebb adatcsere-formátum weben.\n- JavaScriptben a `JSON.stringify()` és `JSON.parse()` a legfontosabb eszközök.\n- Kommunikáció során a Fetch API-val JSON-t küldünk és fogadunk.\n- Mindkét oldalon fontos a helyes adatkezelés és hibakezelés.\n\n---\n\n## Példa kód\n\n```js\n// Adat küldése backendnek\nconst data = { email: 'test@example.com', subscribe: true };\nfetch('https://api.example.com/subscribe', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(data)\n})\n.then(res => res.json())\n.then(responseData => console.log('Válasz:', responseData))\n.catch(err => console.error('Hiba:', err));\n```\n",
  "keyPoints": [
    "JSON a leggyakoribb adatátviteli formátum webes alkalmazásokban.",
    "`JSON.stringify()` objektum konvertálására stringgé.",
    "`JSON.parse()` string konvertálására objektummá.",
    "Fetch API-val JSON adatot küldünk és fogadunk a backenddel.",
    "Fontos a hibakezelés és adatvalidáció mind frontend, mind backend oldalon."
  ]
},
{
  "id": 14,
  "title": "Formok validálása JavaScript-tel",
  "content": "Ebben a leckében megismerkedünk a formok validálásának alapjaival JavaScript segítségével, hogy a felhasználók helyes adatokat adjanak meg.\n\n---\n\n## 1. Miért fontos a validálás?\n\nA formok validálása megakadályozza, hogy hibás vagy hiányos adatok kerüljenek a rendszerbe, így javítva a felhasználói élményt és csökkentve a hibák számát.\n\n---\n\n## 2. Alapvető HTML5 validációs attribútumok\n\n- `required` — kötelező mező\n- `type` — pl. `email`, `number` stb.\n- `minlength` és `maxlength` — minimális és maximális karakterhossz\n- `pattern` — reguláris kifejezés alapú ellenőrzés\n\n---\n\n## 3. JavaScript alapú validáció\n\nJavaScript segítségével egyéni szabályokat is megvalósíthatunk, valamint a hibák visszajelzését személyre szabhatjuk.\n\n### Példa egyszerű validációra:\n\n```js\nconst form = document.querySelector('form');\nform.addEventListener('submit', function(event) {\n  const emailInput = form.querySelector('input[name=\"email\"]');\n  const email = emailInput.value;\n  if (!email.includes('@')) {\n    alert('Érvényes email címet adj meg!');\n    event.preventDefault();\n  }\n});\n```\n\n---\n\n## 4. Hibák megjelenítése\n\n- Megjeleníthetünk üzeneteket az input mellett vagy alatta.\n- Használhatjuk a `setCustomValidity()` metódust az egyéni üzenetekhez.\n\n---\n\n## 5. Valós idejű validáció\n\n- Figyelhetjük az input mezők `input` vagy `change` eseményeit, hogy azonnal visszajelzést adjunk.\n\n```js\nemailInput.addEventListener('input', () => {\n  if (!emailInput.value.includes('@')) {\n    emailInput.setCustomValidity('Hiányzik az @ jel');\n  } else {\n    emailInput.setCustomValidity('');\n  }\n});\n```\n\n---\n\n## 6. Összefoglalás\n\n- Használjunk HTML5 attribútumokat alap validációhoz.\n- Egyéni szabályokat JavaScript-tel valósítsunk meg.\n- Adjunk világos visszajelzést a felhasználónak.\n- Valós idejű validációval javítsuk a UX-et.\n\n---\n\n## Példa HTML és JS kód\n\n```html\n<form id=\"myForm\">\n  <label for=\"email\">Email:</label>\n  <input type=\"email\" name=\"email\" id=\"email\" required />\n  <button type=\"submit\">Küldés</button>\n</form>\n<script>\n  const form = document.getElementById('myForm');\n  const emailInput = document.getElementById('email');\n  form.addEventListener('submit', e => {\n    if (!emailInput.value.includes('@')) {\n      alert('Érvényes email címet adj meg!');\n      e.preventDefault();\n    }\n  });\n</script>\n```\n",
  "keyPoints": [
    "A form validálása alapvető a hibák megelőzéséhez.",
    "HTML5 attribútumok (required, type, pattern) segítik az alapvalidációt.",
    "JavaScript segítségével egyedi szabályokat is megvalósíthatunk.",
    "Valós idejű validáció javítja a felhasználói élményt.",
    "Fontos a hibák világos és érthető megjelenítése."
  ]
},
{
  "id": 15,
  "title": "LocalStorage és SessionStorage használata",
  "content": "Ebben a leckében megismerkedünk a böngésző tárolási lehetőségeivel: LocalStorage és SessionStorage.\n\n---\n\n## 1. Mi az a LocalStorage és SessionStorage?\n\n- **LocalStorage:** Tartós adatokat tárol a böngészőben, amik akkor is megmaradnak, ha bezárod az oldalt vagy a böngészőt.\n- **SessionStorage:** Csak az adott böngészőablak vagy fül életciklusa alatt tárol adatot, az ablak vagy fül bezárásakor törlődik.\n\n---\n\n## 2. Alapműveletek\n\nMindkettő kulcs-érték párokat tárol szövegként.\n\n- **Adat mentése:**\n\n```js\nlocalStorage.setItem('kulcs', 'érték');\nsessionStorage.setItem('kulcs', 'érték');\n```\n\n- **Adat lekérése:**\n\n```js\nconst data = localStorage.getItem('kulcs');\nconst sessionData = sessionStorage.getItem('kulcs');\n```\n\n- **Adat törlése:**\n\n```js\nlocalStorage.removeItem('kulcs');\nsessionStorage.removeItem('kulcs');\n```\n\n- **Összes adat törlése:**\n\n```js\nlocalStorage.clear();\nsessionStorage.clear();\n```\n\n---\n\n## 3. Példa használatra\n\n```js\n// Mentés\nlocalStorage.setItem('username', 'hunor');\n\n// Lekérés\nconst username = localStorage.getItem('username');\nconsole.log(username); // 'hunor'\n\n// Törlés\nlocalStorage.removeItem('username');\n```\n\n---\n\n## 4. Fontos tudnivalók\n\n- Csak szöveges adatot tárolhatunk, ezért komplex objektumokat JSON.stringify-vel kell átalakítani.\n- Adatokat JSON.parse segítségével olvassuk vissza.\n- Nem használható érzékeny adatok tárolására, mert nem biztonságos.\n- Mindkettő tárolási kapacitása körülbelül 5 MB böngészőnként.\n\n---\n\n## 5. Objektumok tárolása\n\n```js\nconst user = { name: 'Hunor', age: 30 };\nlocalStorage.setItem('user', JSON.stringify(user));\n\nconst storedUser = JSON.parse(localStorage.getItem('user'));\nconsole.log(storedUser.name); // Hunor\n```\n\n---\n\n## 6. Összefoglalás\n\n- LocalStorage és SessionStorage egyszerű módja az adatok kliensoldali tárolásának.\n- LocalStorage tartós, SessionStorage csak az aktuális munkamenet idejére szól.\n- Csak szöveges adatokat tárol, objektumokhoz JSON.\n\n---",
  "keyPoints": [
    "LocalStorage tartós adatokat tárol, SessionStorage csak a munkamenet idejére.",
    "Kulcs-érték párokként lehet adatokat elmenteni és lekérni.",
    "Csak szöveges adat tárolható, objektumokat JSON-sá kell alakítani.",
    "Nem biztonságos érzékeny adatok tárolására.",
    "Tárolási kapacitás körülbelül 5 MB."
  ]
},
{
  "id": 16,
  "title": "Alapvető hibakezelés – try/catch",
  "content": "Ebben a leckében megismerkedünk a JavaScript hibakezelés alapjaival, különösen a `try/catch` szerkezettel.\n\n---\n\n## 1. Miért fontos a hibakezelés?\n\nA hibakezelés segít megakadályozni, hogy egy futási hiba leállítsa az egész programot, és lehetőséget ad arra, hogy megfelelő módon reagáljunk rá.\n\n---\n\n## 2. A try/catch szerkezet\n\nA `try` blokkban helyezzük el azt a kódot, amelynél hiba léphet fel. Ha hiba történik, a vezérlés átugrik a `catch` blokkba, ahol kezelhetjük a hibát.\n\n```js\ntry {\n  // Kockázatos kód\n  let result = someFunction();\n  console.log(result);\n} catch (error) {\n  // Hibakezelés\n  console.error('Hiba történt:', error.message);\n}\n```\n\n---\n\n## 3. A finally blokk\n\nA `finally` blokk opcionális, és akkor fut le, amikor a `try` és `catch` blokkok befejeződtek, függetlenül attól, hogy volt-e hiba vagy sem.\n\n```js\ntry {\n  // Kód\n} catch (error) {\n  // Hibakezelés\n} finally {\n  // Mindig lefut\n  console.log('Fut a finally blokk.');\n}\n```\n\n---\n\n## 4. Példa hibakezelésre\n\n```js\nfunction parseJSON(jsonString) {\n  try {\n    const data = JSON.parse(jsonString);\n    console.log('Sikeres feldolgozás:', data);\n  } catch (error) {\n    console.error('Hibás JSON formátum:', error.message);\n  }\n}\n\nparseJSON('{ \"name\": \"Hunor\" }'); // siker\nparseJSON('{ name: Hunor }'); // hiba\n```\n\n---\n\n## 5. Összefoglalás\n\n- A `try` blokkba tesszük a kockázatos kódot.\n- A `catch` blokk kezeli a hibát.\n- A `finally` blokk opcionális, mindig lefut.\n- A hibakezelés növeli a program stabilitását és felhasználói élményt.\n\n---",
  "keyPoints": [
    "A try/catch szerkezet segít a hibák kezelésében futás közben.",
    "A try blokkban van a kockázatos kód, a catch blokk kezeli a hibákat.",
    "A finally blokk mindig lefut, akár volt hiba, akár nem.",
    "Hibakezelés nélkül a hibák megállíthatják a programot.",
    "Például JSON feldolgozásnál jól jön a try/catch."
  ]
},
{
  "id": 17,
  "title": "JavaScript és események haladó technikái (event delegation stb.)",
  "content": "Ebben a leckében a JavaScript eseménykezelés haladóbb technikáit ismerheted meg, különös tekintettel az **event delegation**-re és egyéb hatékony megoldásokra.\n\n---\n\n## 1. Event delegation (eseménydelegálás)\n\nAz eseménydelegálás azt jelenti, hogy nem minden egyes elemen külön-külön kezeljük az eseményeket, hanem egy közös őselemen kezelünk egy adott eseményt, amely így \"delegálja\" az eseményeket a gyermekelemekre.\n\n### Miért hasznos?\n- Kevesebb eseménykezelő, jobb teljesítmény\n- Dinamikusan létrehozott elemekre is működik\n\n### Példa:\n\n```js\n// Van egy lista, amiben több elem lehet\nconst list = document.querySelector('#myList');\n\nlist.addEventListener('click', function(event) {\n  if (event.target && event.target.matches('li.item')) {\n    console.log('Kattintottál egy listára:', event.target.textContent);\n  }\n});\n```\n\n---\n\n## 2. Esemény buborékolás és elkapás (bubbling és capturing)\n\n- **Bubbling:** az esemény az elemről felfelé halad az őselemek felé\n- **Capturing:** az esemény az őselemről lefelé halad a cél elemig\n\nAlapértelmezés szerint a legtöbb esemény buborékol.\n\n### Példa capturing használatára:\n\n```js\nelement.addEventListener('click', handler, true); // true = capturing mód\n```\n\n---\n\n## 3. Esemény leállítása\n\n- `event.stopPropagation()` megakadályozza, hogy az esemény tovább buborékoljon vagy kapkodjon\n- `event.preventDefault()` megakadályozza az esemény alapértelmezett viselkedését (pl. link kattintás)\n\n---\n\n## 4. Egyéb haladó eseménykezelési tippek\n\n- **Once:** Az eseménykezelő csak egyszer fut le\n\n```js\nbutton.addEventListener('click', handler, { once: true });\n```\n\n- **Passive:** Jelzi, hogy az esemény nem fogja megakadályozni az alapértelmezett viselkedést, javítja a görgetés teljesítményt\n\n```js\nwindow.addEventListener('scroll', handler, { passive: true });\n```\n\n---\n\n## 5. Összefoglalás\n\n- Event delegation segítségével kevesebb eseménykezelőt használhatsz,\n- Buborékolási és capturing fázisokat is ismerd,\n- Használd a `stopPropagation` és `preventDefault` módszereket okosan,\n- Használd a haladó opciókat, mint `once` és `passive` a teljesítményért.\n\n---",
  "keyPoints": [
    "Event delegation segítségével egy eseménykezelővel kezelhetsz sok elemet.",
    "Az események két fázisban terjednek: capturing és bubbling.",
    "A stopPropagation megállítja az esemény további terjedését.",
    "A preventDefault megakadályozza az esemény alapértelmezett működését.",
    "A once és passive opciók segítenek a hatékony eseménykezelésben."
  ]
},
{
  "id": 18,
  "title": "DOM fa mélyebb kezelése és manipulációja",
  "content": "Ebben a leckében a DOM (Document Object Model) fa részletesebb kezelésével és manipulációjával ismerkedünk meg, hogy hatékonyabban tudjuk dinamikusan változtatni az oldal tartalmát.\n\n---\n\n## 1. DOM fa alapjai\n\nA DOM fa egy hierarchikus struktúra, ahol minden elem, attribútum és szövegrész egy-egy csomópont (node).\n\n### Node típusok:\n- **Element node:** HTML elemek (pl. `<div>`, `<p>`)\n- **Text node:** szövegek az elemekben\n- **Attribute node:** attribútumok (pl. `class`, `id`)\n\n---\n\n## 2. Navigálás a DOM fában\n\n### Gyermekek és szülők elérése:\n\n```js\nconst elem = document.querySelector('#myElement');\n\n// Gyermekek (csak element node-ok)\nconst children = elem.children;\n\n// Szülő\nconst parent = elem.parentElement;\n\n// Első és utolsó gyermek\nconst firstChild = elem.firstElementChild;\nconst lastChild = elem.lastElementChild;\n\n// Testvérek\nconst nextSibling = elem.nextElementSibling;\nconst prevSibling = elem.previousElementSibling;\n```\n\n### Teljes node-k (beleértve text node-okat) is elérhetők:\n\n```js\nconst childNodes = elem.childNodes; // NodeList, tartalmaz text és elem node-okat is\n```\n\n---\n\n## 3. Új elemek létrehozása és beszúrása\n\n```js\nconst newDiv = document.createElement('div');\nnewDiv.textContent = 'Új elem';\n\nconst container = document.querySelector('#container');\ncontainer.appendChild(newDiv); // Beszúr az utolsó gyermekként\n```\n\n### Beszúrás más pozíciókra:\n\n```js\ncontainer.insertBefore(newDiv, container.firstChild); // Beszúrás az első helyre\n```\n\n---\n\n## 4. Elem eltávolítása\n\n```js\nconst elemToRemove = document.querySelector('.remove-me');\nelemToRemove.remove(); // Egyszerű módszer\n```\n\n---\n\n## 5. Elem másolása (klónozása)\n\n```js\nconst clone = elem.cloneNode(true); // true = mély másolat, az összes gyermekével együtt\ncontainer.appendChild(clone);\n```\n\n---\n\n## 6. Tartalom manipuláció\n\n- **textContent** – csak szöveget állít be vagy olvas\n- **innerHTML** – HTML tartalmat állít be vagy olvas\n\n---\n\n## 7. Összefoglalás\n\n- A DOM fa egy hierarchikus struktúra, amiben elem, szöveg és attribútum node-ok vannak.\n- Különböző módon navigálhatsz az elemek között, figyelve a node típusokra.\n- Új elemeket hozhatsz létre, beszúrhatsz, eltávolíthatsz vagy másolhatsz.\n- A textContent és innerHTML között fontos különbség van.\n\n---",
  "keyPoints": [
    "A DOM fa többféle node típusból áll: element, text, attribútum.",
    "Navigálás a DOM fában: szülők, gyermekek, testvérek elérése.",
    "Új elemek létrehozása, beszúrása különböző helyekre.",
    "Elemek eltávolítása egyszerűen a remove() metódussal.",
    "Elemek klónozása a cloneNode(true) használatával.",
    "Szöveg és HTML tartalom manipulációja textContent és innerHTML segítségével."
  ]
},
{
  "id": 19,
  "title": "Animációk JavaScript segítségével (requestAnimationFrame)",
  "content": "Ebben a leckében megismerkedünk a JavaScript alapú animációk készítésével, különösen a `requestAnimationFrame` API használatával, ami hatékonyabb és simább animációkat tesz lehetővé, mint a hagyományos időzítők.\n\n---\n\n## 1. Mi az a requestAnimationFrame?\n\nA `requestAnimationFrame` egy böngésző API, amely arra kéri a böngészőt, hogy hajtson végre egy animációs lépést, és ezt a lépést a következő újrafestéskor (frame) futtatja le. Ezáltal optimalizált, energiatakarékos és sima animációt kapunk.\n\n```js\nfunction animate(time) {\n  // Animáció lépései itt\n  requestAnimationFrame(animate);\n}\n\nrequestAnimationFrame(animate);\n```\n\n- A `time` paraméter a böngésző által biztosított időbélyeg (timestamp).\n\n---\n\n## 2. Egyszerű példa: Mozgatás\n\nMozgassunk egy elemet vízszintesen 0-tól 300 pixelig:\n\n```html\n<div id=\"box\" style=\"width:50px; height:50px; background:red; position:absolute;\"></div>\n<script>\n  const box = document.getElementById('box');\n  let pos = 0;\n\n  function animate() {\n    pos += 2; // sebesség\n    box.style.left = pos + 'px';\n    if (pos < 300) {\n      requestAnimationFrame(animate);\n    }\n  }\n\n  requestAnimationFrame(animate);\n</script>\n```\n\n---\n\n## 3. Idő alapú animáció\n\nFontos az animációt időhöz kötni, nem csak frame-hez, így a sebesség állandó marad:\n\n```js\nlet start = null;\nfunction animate(timestamp) {\n  if (!start) start = timestamp;\n  const progress = timestamp - start;\n  const distance = Math.min(progress / 10, 300); // 300px 3000ms alatt\n  box.style.left = distance + 'px';\n  if (distance < 300) {\n    requestAnimationFrame(animate);\n  }\n}\nrequestAnimationFrame(animate);\n```\n\n---\n\n## 4. Animáció leállítása és újraindítása\n\nA `requestAnimationFrame` visszatér egy azonosítóval, amit a `cancelAnimationFrame`-mel lehet törölni:\n\n```js\nlet animationId;\nfunction animate() {\n  // ... animáció lépései\n  animationId = requestAnimationFrame(animate);\n}\nanimationId = requestAnimationFrame(animate);\n\n// Megállítás\ncancelAnimationFrame(animationId);\n```\n\n---\n\n## 5. Összefoglalás\n\n- A `requestAnimationFrame` hatékony és szinkron animációkat tesz lehetővé.\n- Idő alapú animációval biztosítható az állandó sebesség minden eszközön.\n- Az animáció leállítható és újraindítható azonosító segítségével.\n\n---\n\n### Hasznos linkek:\n- [MDN requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)\n\n---",
  "keyPoints": [
    "A requestAnimationFrame a böngésző újrafestési ciklusához igazítja az animációkat.",
    "Idő alapú animáció biztosítja az állandó sebességet különböző frame rate mellett.",
    "Az animáció leállítható a cancelAnimationFrame segítségével.",
    "requestAnimationFrame jobban teljesít és energiatakarékosabb, mint a setTimeout vagy setInterval."
  ]
},
{
  "id": 20,
  "title": "Web API-k alapjai (pl. Geolocation, Notification)",
  "content": "Ebben a leckében megismerkedünk a böngészők által biztosított Web API-kkal, amelyekkel kiterjeszthetjük webalkalmazásunk funkcionalitását, például helyadatok lekérése vagy értesítések küldése.\n\n---\n\n## 1. Mi az a Web API?\n\nA Web API-k a böngészők által nyújtott programozási felületek, amelyek segítségével a JavaScript kommunikálhat a böngésző vagy a rendszer egyes szolgáltatásaival.\n\n---\n\n## 2. Geolocation API\n\nLehetővé teszi a felhasználó földrajzi helyzetének lekérését (pl. GPS koordináták). A használathoz engedélyt kell kérni.\n\n### Példa:\n\n```js\nif ('geolocation' in navigator) {\n  navigator.geolocation.getCurrentPosition(\n    position => {\n      console.log('Latitude:', position.coords.latitude);\n      console.log('Longitude:', position.coords.longitude);\n    },\n    error => {\n      console.error('Hiba a helyzet lekérésekor:', error.message);\n    }\n  );\n} else {\n  console.log('Geolocation nem támogatott ezen a böngészőn.');\n}\n```\n\n---\n\n## 3. Notification API\n\nLehetővé teszi webes értesítések küldését a felhasználó eszközére.\n\n### Engedélykérés és értesítés küldése:\n\n```js\nif ('Notification' in window) {\n  Notification.requestPermission().then(permission => {\n    if (permission === 'granted') {\n      new Notification('Helló! Ez egy web értesítés.');\n    }\n  });\n} else {\n  console.log('Értesítések nem támogatottak.');\n}\n```\n\n---\n\n## 4. Egyéb hasznos Web API-k\n\n- **Clipboard API** – vágólap kezelése\n- **Fetch API** – hálózati kérések\n- **Web Storage API** – helyi adattárolás (LocalStorage, SessionStorage)\n- **Device Orientation API** – eszköz mozgás érzékelése\n\n---\n\n## 5. Biztonsági és adatvédelmi megfontolások\n\n- Sok API-hoz (pl. geolocation, kamera, mikrofon) felhasználói engedély kell.\n- Csak HTTPS kapcsolaton keresztül érhetőek el biztonsági okokból.\n\n---\n\n## 6. Összefoglalás\n\n- A Web API-k segítségével bővíthetjük webalkalmazásunk képességeit.\n- Fontos az engedélykérés és a felhasználó adatainak védelme.\n- Mindig ellenőrizni kell az API támogatottságát a böngészőben.\n\n---\n\n### Példa HTML + JavaScript:\n\n```html\n<button id=\"getLocation\">Helyzet lekérése</button>\n<script>\n  document.getElementById('getLocation').addEventListener('click', () => {\n    if ('geolocation' in navigator) {\n      navigator.geolocation.getCurrentPosition(\n        pos => alert(`Latitude: ${pos.coords.latitude}, Longitude: ${pos.coords.longitude}`),\n        err => alert('Nem sikerült lekérni a helyzetet')\n      );\n    } else {\n      alert('Geolocation nem elérhető');\n    }\n  });\n</script>\n```\n",
  "keyPoints": [
    "A Web API-k a böngésző szolgáltatásait teszik elérhetővé JavaScript számára.",
    "A Geolocation API-val megkérhetjük és használhatjuk a felhasználó helyzetét.",
    "A Notification API-val értesítéseket küldhetünk, de engedély kell hozzá.",
    "Biztonsági okokból sok API csak HTTPS alatt működik és engedélykérés kötelező.",
    "Mindig ellenőrizzük, hogy a böngésző támogatja-e az adott API-t."
  ]
},
{
  "id": 21,
  "title": "JavaScript Date és időkezelés",
  "content": "Ebben a leckében megismerkedünk a JavaScript beépített `Date` objektumával, amely lehetővé teszi az idő és dátum kezelését, lekérését és formázását.\n\n---\n\n## 1. Date objektum létrehozása\n\nA `Date` objektumot többféleképpen is létrehozhatjuk:\n\n```js\nconst now = new Date(); // aktuális dátum és idő\nconst specificDate = new Date('2025-06-01T12:00:00'); // konkrét dátum és idő\nconst fromTimestamp = new Date(1654041600000); // milliszekundumból\n```\n\n---\n\n## 2. Dátum és idő lekérése\n\nFontosabb metódusok:\n\n- `getFullYear()` – év\n- `getMonth()` – hónap (0-11, ahol 0 = január)\n- `getDate()` – nap (1-31)\n- `getHours()` – óra (0-23)\n- `getMinutes()` – perc (0-59)\n- `getSeconds()` – másodperc (0-59)\n\n```js\nconst now = new Date();\nconsole.log(now.getFullYear()); // pl. 2025\nconsole.log(now.getMonth()); // pl. 5 (június)\nconsole.log(now.getDate()); // pl. 1\n```\n\n---\n\n## 3. Dátum és idő beállítása\n\n- `setFullYear(year)`\n- `setMonth(month)`\n- `setDate(day)`\n- `setHours(hour)` stb.\n\n```js\nconst date = new Date();\ndate.setFullYear(2024);\ndate.setMonth(11); // december\nconsole.log(date);\n```\n\n---\n\n## 4. Időmérések és különbségek számítása\n\n- Időbélyeg lekérése milliszekundumban: `date.getTime()` vagy `Date.now()`\n- Két dátum különbsége milliszekundumban:\n\n```js\nconst start = new Date('2025-06-01');\nconst end = new Date('2025-06-10');\nconst diffMs = end - start; // különbség milliszekundumban\nconst diffDays = diffMs / (1000 * 60 * 60 * 24); // napokban\nconsole.log(diffDays); // 9\n```\n\n---\n\n## 5. Formázás\n\nJavaScript alapból nem rendelkezik részletes formázási metódusokkal, ezért gyakran használunk külső könyvtárakat (pl. `date-fns`, `moment.js`). Egyszerű formázás az `Intl.DateTimeFormat`-pal:\n\n```js\nconst date = new Date();\nconst formatter = new Intl.DateTimeFormat('hu-HU', { year: 'numeric', month: 'long', day: 'numeric' });\nconsole.log(formatter.format(date));\n```\n\n---\n\n## 6. Időzónák kezelése\n\nA `Date` objektum alapértelmezetten a böngésző helyi időzónáját használja.\n\n---\n\n## 7. Összefoglalás\n\n- A `Date` objektum a dátum és idő kezelés alapja JavaScript-ben.\n- Több metódus áll rendelkezésre dátumok lekérésére és beállítására.\n- Különbségek számítása egyszerűen megoldható.\n- Komplexebb formázáshoz érdemes külső könyvtárakat használni.\n\n---\n\n### Példa kód:\n\n```js\nconst now = new Date();\nconsole.log('Most van:', now);\n\nconst birthday = new Date('1990-05-15T00:00:00');\nconsole.log('Születési dátum:', birthday.toISOString());\n\nconst diff = Date.now() - birthday.getTime();\nconst days = Math.floor(diff / (1000 * 60 * 60 * 24));\nconsole.log(`Eltelt napok születésnap óta: ${days}`);\n```\n",
  "keyPoints": [
    "A Date objektum kezeli a dátumot és időt JavaScript-ben.",
    "Több metódus létezik a dátum és idő lekérésére és beállítására.",
    "Két dátum különbsége egyszerűen kiszámolható milliszekundumban.",
    "Formázáshoz használhatjuk az Intl.DateTimeFormat-ot vagy külső könyvtárakat.",
    "A Date alapértelmezetten a helyi időzónát használja."
  ]
},
{
  "id": 22,
  "title": "JavaScript Szöveg- és karakterlánc műveletek",
  "content": "Ebben a leckében megismerkedünk a JavaScript string (karakterlánc) típusával és a hozzá kapcsolódó gyakori műveletekkel.\n\n---\n\n## 1. String létrehozása\n\n```js\nconst str1 = \"Helló világ!\";\nconst str2 = 'JavaScript tanulás';\nconst str3 = `Template string példája`;\n```\n\n---\n\n## 2. Alapvető string műveletek\n\n- Hossz lekérése: `str.length`\n- Karakter lekérése index alapján: `str.charAt(index)` vagy `str[index]`\n- Karakterlánc összeillesztése: `+` operátor vagy template string `${}`\n\n```js\nconst szoveg = \"Hello\";\nconsole.log(szoveg.length); // 5\nconsole.log(szoveg.charAt(1)); // 'e'\nconsole.log(szoveg + \" világ!\"); // 'Hello világ!'\n```\n\n---\n\n## 3. String metódusok\n\n- `toUpperCase()` és `toLowerCase()` – nagy- és kisbetűsítés\n- `includes(substring)` – tartalmazza-e az adott részt\n- `indexOf(substring)` – első előfordulás helye\n- `slice(start, end)` – részkarakterlánc kivágása\n- `trim()` – szóközök eltávolítása a széléről\n- `replace(search, replace)` – csere\n\n```js\nconst szoveg = \"  Hello Világ!  \";\nconsole.log(szoveg.trim()); // 'Hello Világ!'\nconsole.log(szoveg.toUpperCase()); // '  HELLO VILÁG!  '\nconsole.log(szoveg.includes('Világ')); // true\nconsole.log(szoveg.indexOf('o')); // 4\nconsole.log(szoveg.slice(2, 7)); // 'Hello'\nconsole.log(szoveg.replace('Világ', 'JavaScript')); // '  Hello JavaScript!  '\n```\n\n---\n\n## 4. Template stringek (backtick ` használata)\n\nKényelmes módja a változók és kifejezések beillesztésének:\n\n```js\nconst nev = 'Anna';\nconst uzenet = `Helló, ${nev}! Ma ${new Date().getFullYear()} van.`;\nconsole.log(uzenet); // Helló, Anna! Ma 2025 van.\n```\n\n---\n\n## 5. Tömbbé alakítás és vissza\n\n- `split(delimiter)` – string darabolása tömbbé\n- `join(separator)` – tömb elemeinek összefűzése stringgé\n\n```js\nconst mondat = \"JavaScript egy nagyszerű nyelv\";\nconst szavak = mondat.split(' ');\nconsole.log(szavak); // ['JavaScript', 'egy', 'nagyszerű', 'nyelv']\n\nconst ujMondat = szavak.join('-');\nconsole.log(ujMondat); // 'JavaScript-egy-nagyszerű-nyelv'\n```\n\n---\n\n## 6. Összefoglalás\n\n- Stringek létrehozása többféleképpen (idézőjel, aposztróf, backtick).\n- Alapvető műveletek: hossz, karakter lekérése, összeillesztés.\n- Gyakori metódusok: nagybetű, kisbetű, keresés, részstring, csere, szóköz eltávolítás.\n- Template stringek dinamikus szöveg generálásra.\n- String és tömb átalakítása split és join segítségével.\n\n---\n\n### Példa kód:\n\n```js\nconst nev = \"Gábor\";\nconst koszontes = `Szia, ${nev}!`;\n\nconsole.log(koszontes); // Szia, Gábor!\n\nconst mondat = \"Ez egy példa szöveg.\";\nconst szavak = mondat.split(' ');\nconsole.log(szavak);\n\nconst ujMondat = szavak.join(' | ');\nconsole.log(ujMondat);\n```\n",
  "keyPoints": [
    "A string típus szöveges adatok kezelésére szolgál JavaScript-ben.",
    "Számos beépített metódus segíti a szöveg manipulálását.",
    "Template stringek segítségével egyszerű a változók beillesztése.",
    "A split és join metódusokkal könnyen átalakíthatók stringek és tömbök.",
    "Stringek karakterei index alapján is elérhetők."
  ]
},
{
  "id": 23,
  "title": "JavaScript Matematikai műveletek és véletlenszám generálás",
  "content": "Ebben a leckében megismerkedünk a JavaScript matematikai műveleteivel és a véletlenszám generálás alapjaival.\n\n---\n\n## 1. Alapvető matematikai műveletek\n\nJavaScript-ben a következő operátorokat használjuk:\n\n- Összeadás: `+`\n- Kivonás: `-`\n- Szorzás: `*`\n- Osztás: `/`\n- Maradékos osztás (modulus): `%`\n\n```js\nconst a = 10;\nconst b = 3;\nconsole.log(a + b); // 13\nconsole.log(a - b); // 7\nconsole.log(a * b); // 30\nconsole.log(a / b); // 3.3333...\nconsole.log(a % b); // 1\n```\n\n---\n\n## 2. Math objektum\n\nJavaScript-ben a matematikai műveletekhez és konstansokhoz a `Math` objektumot használjuk.\n\n### Fontosabb metódusok:\n\n- `Math.round(x)` – kerekítés a legközelebbi egészre\n- `Math.floor(x)` – lefelé kerekítés\n- `Math.ceil(x)` – felfelé kerekítés\n- `Math.abs(x)` – abszolút érték\n- `Math.pow(x, y)` – hatványozás (x a y-ediken)\n- `Math.sqrt(x)` – négyzetgyök\n- `Math.max(a, b, c, ...)` – maximum érték\n- `Math.min(a, b, c, ...)` – minimum érték\n\n```js\nconsole.log(Math.round(3.6)); // 4\nconsole.log(Math.floor(3.9)); // 3\nconsole.log(Math.ceil(3.1)); // 4\nconsole.log(Math.abs(-5)); // 5\nconsole.log(Math.pow(2, 3)); // 8\nconsole.log(Math.sqrt(16)); // 4\nconsole.log(Math.max(5, 10, 3)); // 10\nconsole.log(Math.min(5, 10, 3)); // 3\n```\n\n---\n\n## 3. Véletlenszám generálás\n\n### `Math.random()`\n\nEz egy véletlenszámot ad 0 (beleértve) és 1 (nem beleértve) között.\n\n```js\nconst rand = Math.random();\nconsole.log(rand); // pl. 0.345678\n```\n\n### Véletlenszám generálása adott tartományban\n\n```js\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nconsole.log(getRandomInt(1, 10)); // 1 és 10 közötti egész szám\n```\n\n---\n\n## 4. Összefoglalás\n\n- JavaScript alapműveletek: +, -, *, /, %\n- A `Math` objektum sok hasznos metódust kínál matematikai műveletekhez.\n- `Math.random()` 0 és 1 közötti véletlen számot ad.\n- Egész véletlenszám generálható adott intervallumban saját függvénnyel.\n\n---\n\n### Példa kód:\n\n```js\n// Alap műveletek\nconst x = 15;\nconst y = 4;\nconsole.log(x % y); // 3\n\n// Véletlenszám 1 és 100 között\nfunction randomBetween1and100() {\n  return Math.floor(Math.random() * 100) + 1;\n}\nconsole.log(randomBetween1and100());\n```\n",
  "keyPoints": [
    "Alapvető matematikai operátorok: +, -, *, /, %.",
    "A Math objektum metódusai kerekítéshez, abszolút értékhez, hatványozáshoz és négyzetgyökhöz.",
    "Math.random() véletlenszámot generál 0 és 1 között.",
    "Egész véletlenszám generálható adott tartományban saját függvénnyel."
  ]
},
{
  "id": 24,
  "title": "Reguláris kifejezések használata JavaScript-ben",
  "content": "Ebben a leckében megismerkedünk a reguláris kifejezésekkel (regex) és azok használatával JavaScript-ben.\n\n---\n\n## 1. Mi az a reguláris kifejezés?\n\nA reguláris kifejezés egy speciális minta, amely segítségével szövegekben kereshetünk, ellenőrizhetünk, vagy cserélhetünk karaktereket.\n\n## 2. Regex létrehozása\n\nKét módon hozhatunk létre reguláris kifejezést JavaScript-ben:\n\n- Literál szintaxissal:\n```js\nconst regex = /abc/;\n```\n- Konstruktorral:\n```js\nconst regex = new RegExp('abc');\n```\n\n## 3. Alapvető metódusok\n\n### `.test()`\nEllenőrzi, hogy a minta megtalálható-e a szövegben, visszaad egy boolean értéket.\n\n```js\nconst regex = /hello/;\nconsole.log(regex.test('hello world')); // true\nconsole.log(regex.test('hi there'));    // false\n```\n\n### `.exec()`\nMegkeresi a mintát, és visszaadja az első találatot egy tömbben, vagy `null`-t, ha nincs találat.\n\n```js\nconst regex = /world/;\nconst result = regex.exec('hello world');\nconsole.log(result[0]); // 'world'\n```\n\n### String metódusok regex-szel\n\n- `match()`: visszaadja a regexnek megfelelő részeket.\n- `replace()`: lecseréli a regexnek megfelelő részeket.\n- `search()`: visszaadja az első találat indexét.\n\n```js\nconst str = 'apple, banana, cherry';\nconsole.log(str.match(/a/g)); // ['a', 'a', 'a']\nconsole.log(str.replace(/banana/, 'orange')); // 'apple, orange, cherry'\nconsole.log(str.search(/cherry/)); // 14\n```\n\n## 4. Regex zászlók (flags)\n\n- `g` – globális keresés (több találat)\n- `i` – kis- és nagybetűtől független\n- `m` – több soros keresés\n\n## 5. Alap regex minták\n\n- `.` – tetszőleges karakter\n- `\\d` – számjegy\n- `\\w` – betű vagy szám\n- `\\s` – szóköz\n- `^` – a szöveg eleje\n- `$` – a szöveg vége\n- `*` – 0 vagy több ismétlés\n- `+` – 1 vagy több ismétlés\n- `?` – 0 vagy 1 ismétlés\n- `{n}` – pontosan n ismétlés\n- `[abc]` – a karakterek bármelyike\n- `(abc)` – csoport\n\n## 6. Példa: email cím ellenőrzése\n\n```js\nconst emailRegex = /^[\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,}$/;\nconsole.log(emailRegex.test('test@example.com')); // true\nconsole.log(emailRegex.test('hiba@com'));        // false\n```\n\n---\n\n## 7. Összefoglalás\n\n- A reguláris kifejezések hatékony eszközök szöveg keresésére és manipulációjára.\n- JavaScript-ben `/pattern/flags` vagy `RegExp` objektum formájában használhatók.\n- Fontos metódusok: `.test()`, `.exec()`, `match()`, `replace()`.\n- Regex minták és zászlók segítségével sokféle keresési szabályt megadhatunk.\n\n---\n\n### Példa kód:\n\n```js\nconst phoneRegex = /^(\\+\\d{1,3}[- ]?)?\\d{10}$/;\nconsole.log(phoneRegex.test('+36 1234567890')); // true\nconsole.log(phoneRegex.test('1234567890'));    // true\nconsole.log(phoneRegex.test('12345'));         // false\n```\n",
  "keyPoints": [
    "Reguláris kifejezés speciális minták szöveg kereséséhez és manipulációjához.",
    "Regex létrehozása literál vagy RegExp konstruktorral.",
    ".test() visszaadja, hogy található-e minta a szövegben.",
    ".exec() visszaadja az első találatot tömbben vagy null-t.",
    "String metódusok: match(), replace(), search() regex-szel.",
    "Zászlók: g (globális), i (kis-nagybetű érzéketlen), m (többsoros).",
    "Alap regex minták: ., \\d, \\w, ^, $, *, +, ?, {n}, [], ()."
  ]
},
{
  "id": 25,
  "title": "Prototípusok és öröklődés JavaScript-ben",
  "content": "Ebben a leckében a JavaScript prototípus alapú öröklődésével ismerkedünk meg, amely kulcsfontosságú a nyelv objektum-orientált működésében.\n\n---\n\n## 1. Mi az a prototípus?\n\nMinden JavaScript objektumnak van egy belső hivatkozása egy másik objektumra, amit prototípusnak nevezünk. Ez a láncolat adja az öröklődés alapját.\n\n## 2. Prototípus lánc (prototype chain)\n\nHa egy objektumban nem található meg egy tulajdonság vagy metódus, a JavaScript a prototípusláncon keres tovább, amíg meg nem találja vagy el nem éri a lánc végét (`null`).\n\n## 3. Példa prototípus láncra:\n\n```js\nconst animal = {\n  speak() {\n    console.log('Hangot ad ki');\n  }\n};\n\nconst dog = Object.create(animal);\ndog.speak(); // Hangot ad ki\n```\n\nItt a `dog` objektum örökli az `animal` metódusát a prototípusán keresztül.\n\n## 4. Konstruktor függvények és prototípus\n\nA konstruktor függvények segítségével létrehozhatunk objektumokat, melyek automatikusan öröklik a konstruktor `prototype` objektumának tulajdonságait.\n\n```js\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  console.log(`Szia, ${this.name}!`);\n};\n\nconst alice = new Person('Alice');\nalice.greet(); // Szia, Alice!\n```\n\n## 5. ES6 osztályok (class) – szintaktikus cukor\n\nAz ES6-os `class` szintaxisa egyszerűsíti a prototípus alapú öröklődést, de alatta a mechanizmus ugyanaz.\n\n```js\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  greet() {\n    console.log(`Szia, ${this.name}!`);\n  }\n}\n\nconst bob = new Person('Bob');\nbob.greet(); // Szia, Bob!\n```\n\n## 6. Öröklődés osztályok között\n\n```js\nclass Animal {\n  speak() {\n    console.log('Valami hang');\n  }\n}\n\nclass Dog extends Animal {\n  speak() {\n    console.log('Vau-vau');\n  }\n}\n\nconst dog = new Dog();\ndog.speak(); // Vau-vau\n```\n\nAz `extends` kulcsszóval hozhatunk létre alosztályokat, melyek öröklik a szülő osztály tulajdonságait.\n\n---\n\n## 7. Összefoglalás\n\n- JavaScript prototípus alapú nyelv, nem osztály alapú.\n- Minden objektumnak van egy prototípusa, amelyből örököl.\n- Konstruktor függvények és `prototype` segítségével adhatunk közös metódusokat.\n- ES6 osztályok a prototípus öröklődést egyszerűbbé teszik.\n- Az `extends` kulcsszóval valósítható meg az öröklődés osztályok között.\n\n---\n\n### Példa kód:\n\n```js\nfunction Vehicle(type) {\n  this.type = type;\n}\n\nVehicle.prototype.describe = function() {\n  console.log(`Ez egy ${this.type}.`);\n};\n\nfunction Car(brand) {\n  Vehicle.call(this, 'autó');\n  this.brand = brand;\n}\n\nCar.prototype = Object.create(Vehicle.prototype);\nCar.prototype.constructor = Car;\n\nCar.prototype.showBrand = function() {\n  console.log(`Márka: ${this.brand}`);\n};\n\nconst myCar = new Car('Toyota');\nmyCar.describe();   // Ez egy autó.\nmyCar.showBrand();  // Márka: Toyota\n```\n",
  "keyPoints": [
    "JavaScript prototípus alapú öröklődést használ, nem osztály alapút.",
    "Minden objektumnak van egy prototípusa, amiből örököl tulajdonságokat és metódusokat.",
    "Prototípus lánc segítségével keres a motor hiányzó tulajdonságokat.",
    "Konstruktor függvények és prototype objektum segítségével definiálhatók közös metódusok.",
    "ES6 class szintaxis egyszerűsíti a prototípus alapú öröklődést.",
    "Az extends kulcsszóval osztályok között is öröklődhetünk."
  ]
},
{
  "id": 26,
  "title": "Osztályok (Classes) ES6-ban",
  "content": "Ebben a leckében megismerkedünk az ES6-ban bevezetett `class` szintaxissal, amely egyszerűbb és áttekinthetőbb módot ad az objektum-orientált programozásra JavaScript-ben.\n\n---\n\n## 1. Mi az az osztály?\n\nAz osztály (class) egy sablon vagy tervrajz objektumok létrehozásához. Az ES6 előtt konstruktor függvényeket használtunk erre a célra, az ES6 pedig bevezette a `class` kulcsszót, amely szintaktikus cukorként (syntactic sugar) egyszerűsíti a prototípus alapú öröklődést.\n\n## 2. Osztály létrehozása\n\n```js\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  greet() {\n    console.log(`Szia, ${this.name}!`);\n  }\n}\n\nconst person1 = new Person('Anna', 30);\nperson1.greet(); // Szia, Anna!\n```\n\n- A `constructor` egy speciális metódus, amit az objektum létrehozásakor hív meg a rendszer.\n- Az osztály metódusai automatikusan a prototípusra kerülnek.\n\n## 3. Getterek és setterek\n\nAz osztályokban könnyen definiálhatunk gettereket és settereket, amelyek egy tulajdonság lekérdezését vagy beállítását szabályozzák.\n\n```js\nclass Rectangle {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n  }\n\n  get area() {\n    return this.width * this.height;\n  }\n\n  set area(value) {\n    this.width = Math.sqrt(value);\n    this.height = Math.sqrt(value);\n  }\n}\n\nconst rect = new Rectangle(4, 5);\nconsole.log(rect.area); // 20\nrect.area = 25;\nconsole.log(rect.width); // 5\nconsole.log(rect.height); // 5\n```\n\n## 4. Statikus metódusok\n\nAz osztályon belül definiálhatunk statikus metódusokat, amelyeket az osztályon magán hívhatunk meg, nem az objektumon.\n\n```js\nclass MathUtil {\n  static square(x) {\n    return x * x;\n  }\n}\n\nconsole.log(MathUtil.square(5)); // 25\n```\n\n## 5. Öröklődés osztályok között\n\n```js\nclass Animal {\n  speak() {\n    console.log('Valami hang');\n  }\n}\n\nclass Dog extends Animal {\n  speak() {\n    console.log('Vau-vau');\n  }\n}\n\nconst dog = new Dog();\ndog.speak(); // Vau-vau\n```\n\n- Az `extends` kulcsszóval hozzuk létre az öröklődést.\n- A szülő osztály metódusait a gyermek osztály átveheti és felülírhatja.\n\n## 6. `super` kulcsszó\n\nA gyermek osztály konstruktorából vagy metódusaiból a `super` kulcsszóval hívhatjuk a szülő osztály metódusait vagy konstruktorát.\n\n```js\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak() {\n    console.log(`${this.name} hangot ad.`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name);\n    this.breed = breed;\n  }\n  speak() {\n    super.speak();\n    console.log('Vau-vau!');\n  }\n}\n\nconst dog = new Dog('Buddy', 'Labrador');\ndog.speak();\n// Buddy hangot ad.\n// Vau-vau!\n```\n\n---\n\n## 7. Összefoglalás\n\n- Az ES6 `class` egyszerűsíti a JavaScript objektum-orientált programozását.\n- Konstruktorral inicializálhatjuk az objektumot.\n- Gettereket és settereket használhatunk tulajdonságok kezelésére.\n- Statikus metódusok az osztály szintjén érhetők el.\n- Öröklődés `extends` és `super` segítségével valósítható meg.\n\n---\n\n### Példa kód:\n\n```js\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  greet() {\n    console.log(`Hello, ${this.name}!`);\n  }\n}\n\nclass Student extends Person {\n  constructor(name, grade) {\n    super(name);\n    this.grade = grade;\n  }\n  study() {\n    console.log(`${this.name} tanul.`);\n  }\n}\n\nconst student1 = new Student('Péter', 10);\nstudent1.greet(); // Hello, Péter!\nstudent1.study(); // Péter tanul.\n```\n",
  "keyPoints": [
    "Az ES6 `class` egy szintaktikus egyszerűsítés a prototípus alapú öröklődéshez.",
    "A `constructor` metódus inicializálja az objektumot.",
    "Getterek és setterek könnyítik a tulajdonságok kezelését.",
    "Statikus metódusok az osztály szintjén érhetők el.",
    "Az `extends` és `super` kulcsszavakkal valósul meg az öröklődés."
  ]
},
{
  "id": 27,
  "title": "Closure-k és lexical scope magyarázata",
  "content": "Ebben a leckében megismerkedünk a JavaScript egyik legfontosabb és legérdekesebb fogalmával, a closure-rel és a lexical scope-dzsal.\n\n---\n\n## 1. Lexical Scope (lexikális hatókör)\n\nA lexikális hatókör azt jelenti, hogy egy változó láthatósága a kód szerkezetétől, azaz a forráskódban való elhelyezkedésétől függ. Egyszerűen: egy függvényben elérhető változók azok, amiket a függvény definiálási helyétől felfelé (a környező blokkokban és globálisan) megtalálunk.\n\n```js\nfunction outer() {\n  const outerVar = 'Ez az outer változó';\n\n  function inner() {\n    console.log(outerVar); // Az inner hozzáfér az outerVar-hoz\n  }\n\n  inner();\n}\n\nouter(); // Kiírja: Ez az outer változó\n```\n\nItt az `inner` függvény eléri az `outer` függvényben definiált `outerVar` változót, mert az lexikálisan (forráskódban) a láthatósági tartományában van.\n\n## 2. Closure (lezárás)\n\nA closure egy függvény és az a környező változók halmaza, amelyet a függvény „bezár”, vagyis megjegyez és hozzáfér hozzájuk akkor is, ha a külső függvény már végrehajtódott.\n\nPélda closure-re:\n\n```js\nfunction makeCounter() {\n  let count = 0;\n  return function() {\n    count++;\n    return count;\n  };\n}\n\nconst counter = makeCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\nconsole.log(counter()); // 3\n```\n\n- A `makeCounter` visszaad egy függvényt, ami használja a `count` változót.\n- Ez a visszaadott függvény bezárja (`closure`) a `count` változót.\n- Még akkor is, ha a `makeCounter` már lefutott, a `count` változó megmarad, mert a visszaadott függvény hozzáfér hozzá.\n\n## 3. Miért hasznos a closure?\n\n- Privát változók megvalósítása\n- Állapot megőrzése egy függvényben\n- Funkcionális programozásban elengedhetetlen\n\n## 4. Closure gyakori hibák\n\n- Többszörös closure hurokban (loop) gyakran előfordul, hogy minden függvény ugyanarra a változóra hivatkozik – ezt meg lehet oldani például `let` használatával vagy IIFE-vel.\n\n```js\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// Kiírja: 0, 1, 2\n```\n\n---\n\n## Összefoglaló:\n\n- A lexical scope határozza meg, hogy a függvény milyen változókat lát.\n- A closure egy függvény és a környezete, amely megőrzi azokat a változókat, amikhez hozzáfér.\n- Closure segítségével létrehozhatunk privát állapotot és funkcionális mintákat.\n\n---\n\n### Példa kód:\n\n```js\nfunction greetingMaker(name) {\n  return function() {\n    console.log('Hello, ' + name + '!');\n  };\n}\n\nconst greetAnna = greetingMaker('Anna');\ngreetAnna(); // Hello, Anna!\n```\n\nEz a függvény bezárja a `name` változót és megőrzi az értékét, így amikor később meghívjuk, az emlékszik rá.",
  "keyPoints": [
    "Lexical scope azt jelenti, hogy a változók láthatósága a kód elhelyezkedésétől függ.",
    "Closure egy függvény és az általa bezárt környező változók halmaza.",
    "Closure lehetővé teszi, hogy egy függvény emlékezzen a környezeti változókra, még a külső függvény lefutása után is.",
    "Closure hasznos privát változók és állapot megőrzésére.",
    "Gyakori hibák closure-rel loop-okban, amit `let` vagy IIFE-vel lehet orvosolni."
  ]
},
{
  "id": 28,
  "title": "Debouncing és throttling technikák JavaScript-ben",
  "content": "Ebben a leckében megismerjük a debouncing és throttling technikákat, melyek segítenek az események kezelésében és a teljesítmény optimalizálásában.\n\n---\n\n## 1. Miért van szükség debouncingra és throttlingra?\n\nGyakran előfordul, hogy egy esemény, például az ablak átméretezése vagy a görgetés, nagyon gyakran fut le, ami lelassíthatja az alkalmazást, és fölösleges számításokat eredményezhet.\n\nA debouncing és throttling segít kontrollálni, hogy ezek az események milyen gyakran váltsanak ki valódi műveletet.\n\n## 2. Debouncing\n\nA debouncing azt jelenti, hogy az eseményhez tartozó funkció csak akkor fut le, ha az esemény nem ismétlődik meg egy bizonyos időintervallumon belül.\n\n### Hogyan működik?\n\n- Ha az esemény többször is megtörténik gyors egymásutánban, a függvény futása késleltetve lesz.\n- Csak akkor fut le, ha az esemény egy adott időintervallumon belül nem ismétlődik.\n\n### Példa:\n\n```js\nfunction debounce(fn, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      fn.apply(this, args);\n    }, delay);\n  };\n}\n\n// Használat\nwindow.addEventListener('resize', debounce(() => {\n  console.log('Ablak átméretezve');\n}, 300));\n```\n\nEbben a példában az üzenet csak akkor jelenik meg, ha az ablak átméretezése után 300 ms-ig nem történik újabb átméretezés.\n\n## 3. Throttling\n\nA throttling azt jelenti, hogy az eseményhez tartozó funkció legfeljebb egy bizonyos időközönként futhat le, függetlenül attól, hogy az esemény milyen gyakran történik.\n\n### Hogyan működik?\n\n- Ha az esemény túl gyakran érkezik, a függvény csak az előre meghatározott időközönként fut le.\n\n### Példa:\n\n```js\nfunction throttle(fn, limit) {\n  let lastCall = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastCall >= limit) {\n      lastCall = now;\n      fn.apply(this, args);\n    }\n  };\n}\n\n// Használat\nwindow.addEventListener('scroll', throttle(() => {\n  console.log('Oldal görgetve');\n}, 200));\n```\n\nEbben a példában a görgetés esemény esetén a log csak legfeljebb 200 ms-onként jelenik meg.\n\n---\n\n## 4. Összefoglalás\n\n- Debounce: várakozik, majd egyetlen alkalommal futtatja a funkciót, ha az esemény nem ismétlődik meg egy adott időn belül.\n- Throttle: korlátozza a funkció futási gyakoriságát, például maximum egyszer egy időegység alatt.\n\n---\n\n### Hasznos lehetőség\n\nEzek a technikák különösen fontosak nagy gyakoriságú eseményeknél (scroll, resize, input), hogy javítsák az alkalmazás teljesítményét és felhasználói élményét.\n\n---\n\n### Példa kód:\n\n```js\n// Debounce példa\nconst debounceExample = debounce(() => {\n  console.log('Debounce példa');\n}, 250);\n\n// Throttle példa\nconst throttleExample = throttle(() => {\n  console.log('Throttle példa');\n}, 250);\n\nwindow.addEventListener('resize', debounceExample);\nwindow.addEventListener('scroll', throttleExample);\n```\n",
  "keyPoints": [
    "Debounce késlelteti a függvény futását, amíg az esemény nem ismétlődik egy adott idő alatt.",
    "Throttle korlátozza, hogy a függvény legfeljebb egyszer fusson egy adott időintervallumban.",
    "Debounce ideális beviteli mezőkhöz vagy ritkán végzett műveletekhez.",
    "Throttle ideális görgetés vagy ablakméret változás esetén, ahol folyamatos frissítés kell.",
    "Mindkét technika segít csökkenteni a fölösleges számításokat és javítja a teljesítményt."
  ]
},
{
  "id": 29,
  "title": "Event loop és aszinkron működés mélyebben JavaScript-ben",
  "content": "Ebben a leckében mélyebben megismerkedünk a JavaScript eseménykezelő mechanizmusával, az event loop-pal és az aszinkron működés alapjaival.\n\n---\n\n## 1. JavaScript futási modell\n\nJavaScript egy egyszálú, eseményvezérelt nyelv, ami azt jelenti, hogy egyszerre csak egy utasítást futtat, de képes aszinkron műveleteket kezelni, így nem blokkolja a fő szálat.\n\n## 2. Call stack (hívási verem)\n\nEz a verem tartja nyilván, hogy éppen melyik függvény fut. Amikor egy függvényt meghívunk, az a verem tetejére kerül, és amikor befejeződik, onnan eltávolítódik.\n\nHa egy hosszú, szinkron művelet fut, akkor a verem blokkolódik, és nem történik más művelet.\n\n## 3. Web APIs és callback queue (várakozási sor)\n\nA böngésző vagy a Node.js környezet külön kezel aszinkron műveleteket (pl. időzítők, hálózati kérések). Ezek a Web API-k kezeli az aszinkron műveleteket.\n\nAmikor egy aszinkron művelet befejeződik, a callback (visszahívó függvény) a callback queue-ba kerül.\n\n## 4. Event loop (eseményhurok)\n\nAz event loop folyamatosan figyeli a call stack-et és a callback queue-t.\n\n- Ha a call stack üres, az event loop áthelyezi a callback queue első elemét a call stack tetejére, így futtatja azt.\n- Ez az az elv, amely lehetővé teszi az aszinkron működést, anélkül, hogy blokkolná a futást.\n\n## 5. Példa:\n\n```js\nconsole.log('Első');\n\nsetTimeout(() => {\n  console.log('Második (aszinkron)');\n}, 0);\n\nconsole.log('Harmadik');\n```\n\n**Kimenet:**\n```\nElső\nHarmadik\nMásodik (aszinkron)\n```\n\n- A `setTimeout` callback-je a Web API-ban vár, majd a callback queue-ba kerül.\n- Az event loop csak akkor veszi elő a callback-et, amikor a call stack üres lesz.\n\n## 6. Mikrofeladatok (microtasks)\n\nA Promise-k és egyes aszinkron műveletek mikrofeladatokként (microtasks) kerülnek feldolgozásra, amelyek a callback queue előtt futnak le.\n\n### Példa:\n\n```js\nconsole.log('Első');\n\nPromise.resolve().then(() => {\n  console.log('Második (microtask)');\n});\n\nconsole.log('Harmadik');\n```\n\n**Kimenet:**\n```\nElső\nHarmadik\nMásodik (microtask)\n```\n\nItt a Promise callback-je a microtask queue-ban van, amit az event loop a call stack ürülése után azonnal futtat, még a setTimeout callback-je előtt.\n\n---\n\n## 7. Összefoglalás\n\n- JavaScript egyszálú, de az event loop segítségével hatékonyan kezeli az aszinkron műveleteket.\n- Call stack kezeli a futó függvényeket, míg a Web API és callback queue a befejezett aszinkron callback-eket.\n- Az event loop biztosítja, hogy a callback-ek csak akkor fussanak le, amikor a fő szál szabad.\n- Mikrofeladatok (Promise-k) prioritást élveznek a sima callback-ekkel szemben.\n\n---\n\n## 8. Hasznos eszközök és linkek\n\n- Chrome DevTools -> Performance panel segítségével lehet követni az event loop működését.\n- [MDN: Concurrency model and Event Loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)\n\n---\n\n### Példa kód:\n\n```js\nconsole.log('Start');\n\nsetTimeout(() => {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise');\n});\n\nconsole.log('End');\n```\n\n**Kimenet:**\n```\nStart\nEnd\nPromise\nsetTimeout\n```\n",
  "keyPoints": [
    "JavaScript egyszálú, de az event loop segíti az aszinkron működést.",
    "Call stack tartja a futó függvényeket, callback queue várja az aszinkron callback-eket.",
    "Event loop figyeli a call stack-et és callback queue-t, és átmozgatja a callback-eket futtatásra.",
    "Promise-k mikrofeladatként (microtasks) futnak, és előbb végrehajtódnak, mint a setTimeout callback-ek.",
    "Az aszinkron JavaScript működésének megértése fontos a hatékony és hibamentes kódíráshoz."
  ]
},
{
  "id": 30,
  "title": "Web Storage API – továbbfejlesztett használat",
  "content": "Ebben a leckében a Web Storage API mélyebb használatával ismerkedünk meg, beleértve a LocalStorage és SessionStorage továbbfejlesztett kezelését.\n\n---\n\n## 1. Rövid ismétlés – LocalStorage és SessionStorage\n\n- **LocalStorage:** Tartós tárolás a böngészőben, a tárolt adatok még böngésző újraindítás után is megmaradnak.\n- **SessionStorage:** Csak a böngészőfül élettartamáig tárol adatokat.\n\nMindkettő kulcs-érték alapú tároló.\n\n## 2. Továbbfejlesztett használat\n\n### 2.1. Objektumok tárolása és visszaolvasása\n\nA Web Storage csak stringeket tárol, ezért objektumokat JSON-né kell alakítani.\n\n```js\nconst user = { id: 1, name: 'Anna', roles: ['admin', 'user'] };\n\n// Tárolás\nlocalStorage.setItem('user', JSON.stringify(user));\n\n// Lekérés\nconst userData = JSON.parse(localStorage.getItem('user'));\nconsole.log(userData.name); // Anna\n```\n\n### 2.2. Adatfrissítés\n\nHa egy tárolt objektumot akarunk frissíteni:\n\n```js\nlet userData = JSON.parse(localStorage.getItem('user')) || {};\nuserData.roles.push('editor');\nlocalStorage.setItem('user', JSON.stringify(userData));\n```\n\n### 2.3. Biztonság és korlátok\n\n- Max tárolási méret ~5MB böngészőnként.\n- Ne tárolj érzékeny adatokat (pl. jelszavak).\n- JSON parse hibakezelése:\n\n```js\ntry {\n  const data = JSON.parse(localStorage.getItem('user'));\n  // használat\n} catch(e) {\n  console.error('Hibás JSON formátum', e);\n}\n```\n\n### 2.4. Események figyelése – `storage` esemény\n\nHa több böngészőablak vagy fül használja ugyanazt a tárolót, az egyik ablakban történő változásról a többiek is értesülhetnek:\n\n```js\nwindow.addEventListener('storage', (event) => {\n  console.log('Módosult a tároló:', event.key, event.newValue);\n});\n```\n\n### 2.5. Tiszta tárolás – törlés és kulcsok kezelése\n\n- Egy adott kulcs törlése:\n\n```js\nlocalStorage.removeItem('user');\n```\n\n- Az összes tárolt adat törlése:\n\n```js\nlocalStorage.clear();\n```\n\n- Kulcs lekérése index alapján:\n\n```js\nconst keyName = localStorage.key(0);\nconsole.log(keyName);\n```\n\n## 3. Gyakorlati tippek\n\n- Használj wrapper függvényeket a JSON parse/stringify körül, hogy elkerüld a hibákat.\n- Az alkalmazás indulásakor érdemes ellenőrizni, hogy elérhető-e a Web Storage (pl. privát böngésző módokban lehet korlátozott).\n\n```js\nfunction safeGetItem(key) {\n  try {\n    return JSON.parse(localStorage.getItem(key));\n  } catch {\n    return null;\n  }\n}\n```\n\n- Többféle tároló használata az adatok természetétől függően (pl. rövid életű adatok SessionStorage-ban).\n\n---\n\n## 4. Összefoglalás\n\n- A Web Storage API egyszerű, mégis hatékony tárolási lehetőséget nyújt a kliensoldalon.\n- A JSON használatával bonyolultabb adatokat is tudunk kezelni.\n- A `storage` esemény lehetővé teszi a többablakos szinkronizációt.\n- Fontos a hibakezelés és a biztonság tudatos kezelése.\n\n---\n\n## 5. További források\n\n- [MDN Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)\n- [Web Storage API események](https://developer.mozilla.org/en-US/docs/Web/API/Window/storage_event)\n\n---\n\n### Példa kód:\n\n```js\n// Biztonságos adatlekérés\nfunction safeGetItem(key) {\n  try {\n    return JSON.parse(localStorage.getItem(key));\n  } catch {\n    return null;\n  }\n}\n\n// Példa használat\nconst user = safeGetItem('user') || { name: 'Ismeretlen' };\nconsole.log(user.name);\n\n// Adat frissítés\nuser.lastLogin = new Date().toISOString();\nlocalStorage.setItem('user', JSON.stringify(user));\n\n// Több ablak szinkronizáció\nwindow.addEventListener('storage', (event) => {\n  if (event.key === 'user') {\n    console.log('User adat változott:', event.newValue);\n  }\n});\n```",
  "keyPoints": [
    "Web Storage API LocalStorage és SessionStorage segítségével tárol kliensoldali adatokat.",
    "Csak stringeket tárol, ezért JSON stringify/parse szükséges összetettebb objektumokhoz.",
    "Fontos a hibakezelés JSON parsing során, és biztonsági megfontolások (ne tárolj érzékeny adatot).",
    "A `storage` esemény figyelése lehetővé teszi a tároló változásainak több böngészőablak közti szinkronizálását.",
    "Használj biztonságos wrapper függvényeket, és figyeld a böngésző támogatottságot."
  ]
},
{
  "id": 31,
  "title": "Error handling és debug technikák JavaScript-ben",
  "content": "Ebben a leckében megismerkedünk a JavaScript hibakezelési és hibakeresési (debug) technikáival, amelyek elengedhetetlenek a stabil és karbantartható kód írásához.\n\n---\n\n## 1. Hibakezelés try/catch segítségével\n\nA `try...catch` blokk lehetővé teszi a futás közbeni hibák kezelését anélkül, hogy a teljes alkalmazás összeomlana.\n\n```js\ntry {\n  // Kód, ahol hiba történhet\n  let result = riskyFunction();\n  console.log(result);\n} catch (error) {\n  // Hibakezelés\n  console.error('Hiba történt:', error.message);\n}\n```\n\n- A `try` blokkban lévő kódot futtatja a JavaScript.\n- Ha hiba lép fel, azonnal ugrik a `catch` blokkba.\n- Az `error` objektum tartalmazza a hiba részleteit.\n\n## 2. throw – saját hibák dobása\n\nSaját hibák is dobhatók, hogy jelezzük a váratlan helyzeteket.\n\n```js\nfunction checkAge(age) {\n  if (age < 18) {\n    throw new Error('Még nem vagy nagykorú!');\n  }\n  return 'Hozzáférés engedélyezve';\n}\n\ntry {\n  console.log(checkAge(16));\n} catch (e) {\n  alert(e.message);\n}\n```\n\n## 3. Debug technikák\n\n### 3.1. console.log és társai\n\n- `console.log()`: általános üzenetek, változók értékeinek kiírása.\n- `console.error()`: hibák jelzése pirossal.\n- `console.warn()`: figyelmeztetések.\n- `console.table()`: táblázatos adatmegjelenítés.\n\n### 3.2. Breakpoint használat a böngésző DevTools-ban\n\n- Megállíthatod a kód futását adott sorban, hogy lépésenként vizsgáld a változókat, kifejezéseket.\n- Chrome, Firefox, Edge fejlesztői eszközök mind rendelkeznek ilyen funkcióval.\n\n### 3.3. Debugger kulcsszó\n\nA `debugger;` kulcsszó beillesztésével a kód végrehajtása megáll, ha meg van nyitva a DevTools:\n\n```js\nfunction test() {\n  let x = 10;\n  debugger;\n  x += 20;\n  return x;\n}\n```\n\n### 3.4. Hálózati hibák és async hibakezelés\n\n- `fetch` vagy más aszinkron műveleteknél a hibákat `catch` blokkal kell kezelni:\n\n```js\nfetch('/api/data')\n  .then(response => response.json())\n  .catch(error => console.error('Hálózati hiba:', error));\n```\n\n- Async/await szintaxissal:\n\n```js\nasync function getData() {\n  try {\n    const response = await fetch('/api/data');\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Hiba:', error);\n  }\n}\n```\n\n## 4. Gyakori hibák felismerése és kezelése\n\n- Szintaxis hibák: hiányzó zárójelek, pontosvesszők.\n- Változó deklarációk helytelen használata.\n- Promise nem kezelt reject esetek.\n- Nem definiált vagy null értékű változók használata.\n\n## 5. Hibák naplózása és monitoring\n\n- Komplex alkalmazásoknál érdemes hibákat külső szolgáltatásnak (pl. Sentry) naplózni.\n- Ez segíti a gyorsabb hibajavítást és a felhasználói élmény javítását.\n\n---\n\n## Összefoglalás\n\n- A `try...catch` alapvető eszköz a hibák kezelésére.\n- Saját hibák dobása `throw` segítségével kontrollált hibakezelést tesz lehetővé.\n- A konzol és a böngésző fejlesztői eszközei nélkülözhetetlenek a hibák megtalálásában.\n- Aszinkron műveleteknél mindig kezeljük a hibákat.\n- Nagyobb projektekben érdemes hibákat naplózni külső szolgáltatásokba.\n\n---\n\n## További források\n\n- [MDN: try...catch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch)\n- [MDN: debugger](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger)\n- [Chrome DevTools Guide](https://developers.google.com/web/tools/chrome-devtools/javascript)\n\n---\n\n### Példa kód\n\n```js\nfunction divide(a, b) {\n  if (b === 0) {\n    throw new Error('Nullával való osztás nem megengedett');\n  }\n  return a / b;\n}\n\ntry {\n  console.log(divide(10, 2)); // 5\n  console.log(divide(5, 0));\n} catch (error) {\n  console.error('Hiba:', error.message);\n}\n\n// Debugger használata\nfunction testDebug() {\n  let x = 5;\n  debugger; // Megáll itt a kód, ha DevTools nyitva van\n  x += 10;\n  return x;\n}\n\nconsole.log(testDebug());\n```",
  "keyPoints": [
    "A `try...catch` blokk használata a hibák kezelésére futás közben.",
    "Saját hibák dobása `throw` kulcsszóval a hibás állapotok jelzésére.",
    "Konzol metódusok (`console.log`, `console.error`, `console.warn`) a hibakereséshez.",
    "Breakpointok és `debugger` kulcsszó használata a böngésző fejlesztői eszközeiben.",
    "Aszinkron hibák kezelése `catch` blokkal és async/await szerkezetben.",
    "Hibák naplózása külső szolgáltatásokba komplex alkalmazások esetén."
  ]
},
{
  "id": 32,
  "title": "JavaScript moduláris tesztelés alapjai",
  "content": "Ebben a leckében megismerkedünk a JavaScript moduláris tesztelés alapjaival, hogy hogyan írhatunk jól strukturált, automatikusan futtatható teszteket, melyek segítenek a kód megbízhatóságának és minőségének javításában.\n\n---\n\n## 1. Mi a moduláris tesztelés?\n\nA moduláris tesztelés (unit testing) során a kód legkisebb egységeit (függvények, osztályok, komponensek) izoláltan teszteljük.\n\n## 2. Miért fontos?\n\n- Hibák korai felismerése\n- Kód karbantarthatóságának javítása\n- Refaktorálás biztonságosabbá tétele\n- Dokumentációként is szolgálhat\n\n## 3. Népszerű JavaScript tesztelési keretrendszerek\n\n- Jest (Facebook által fejlesztett, nagyon népszerű)\n- Mocha + Chai\n- Jasmine\n\n## 4. Egyszerű teszt írása Jest-tel\n\n### Telepítés (Node.js projekt esetén):\n```bash\nnpm install --save-dev jest\n```\n\n### Példa függvény tesztelésére:\n```js\n// calculator.js\nfunction add(a, b) {\n  return a + b;\n}\nmodule.exports = add;\n\n// calculator.test.js\nconst add = require('./calculator');\n\ntest('adds 1 + 2 to equal 3', () => {\n  expect(add(1, 2)).toBe(3);\n});\n```\n\n### Teszt futtatása:\n```bash\nnpx jest\n```\n\n## 5. Alapvető fogalmak\n\n- `test` vagy `it`: egy teszteset definiálása\n- `expect`: elvárt eredmény megadása\n- Matcher függvények: `.toBe()`, `.toEqual()`, `.toContain()`, stb.\n\n## 6. Mockolás (helyettesítés)\n\nAmikor egy modul függ egy másiktól (pl. API hívás), helyettesíthetjük (mock) a függőséget, hogy izoláltan teszteljünk.\n\n```js\njest.mock('./api');\nconst api = require('./api');\napi.fetchData.mockResolvedValue({ data: 'mocked data' });\n```\n\n## 7. Tesztek szervezése\n\n- Több teszt esetet csoportosíthatunk `describe` blokkban\n\n```js\ndescribe('Calculator tests', () => {\n  test('addition works', () => { ... });\n  test('subtraction works', () => { ... });\n});\n```\n\n## 8. További tippek\n\n- Írj kis, jól definiált teszteket\n- Ne tesztelj implementációs részleteket, csak viselkedést\n- Használj folyamatos integrációs (CI) rendszert a tesztek automatikus futtatására\n\n---\n\n## Összefoglalás\n\n- A moduláris tesztelés a kód megbízhatóságának alapja.\n- Jest egy könnyen használható keretrendszer az egységtesztekhez.\n- Tesztek segítenek megelőzni a hibákat és támogatják a biztonságos fejlesztést.\n\n---\n\n### Példa kód\n\n```js\n// összeadás függvény\nfunction add(a, b) {\n  return a + b;\n}\n\n// Teszt fájl (calculator.test.js)\ntest('adds 2 + 3 to equal 5', () => {\n  expect(add(2, 3)).toBe(5);\n});\n```\n\n---\n\n## További források\n\n- [Jest hivatalos dokumentáció](https://jestjs.io/)\n- [Testing JavaScript](https://testingjavascript.com/)\n\n",
  "keyPoints": [
    "Moduláris (unit) tesztelés célja a kód legkisebb egységeinek izolált tesztelése.",
    "Jest egy népszerű teszt keretrendszer JavaScripthez.",
    "Teszt esetek írása `test` vagy `it` függvényekkel, elvárások megadása `expect`-tel.",
    "Mockolás segítségével izolálhatjuk a függőségeket a tesztekben.",
    "`describe` blokkal csoportosíthatjuk a kapcsolódó teszteket.",
    "Tesztelés segít hibák elkerülésében és kódminőség javításában."
  ]
},
{
  "id": 33,
  "title": "Node.js alapok és környezet",
  "content": "Ebben a leckében megismerkedünk a Node.js alapjaival és a fejlesztői környezettel, amely lehetővé teszi JavaScript futtatását szerveren.\n\n---\n\n## 1. Mi az a Node.js?\n\n- Node.js egy JavaScript futtatókörnyezet, amely lehetővé teszi a JavaScript futtatását a böngészőn kívül, főleg szerver oldalon.\n- A Node.js a Google V8 JavaScript motorját használja.\n- Eseményvezérelt, aszinkron I/O modell jellemzi, amely hatékony és skálázható.\n\n## 2. Node.js telepítése\n\n- Látogass el a https://nodejs.org oldalra.\n- Válaszd ki az operációs rendszerednek megfelelő verziót (LTS ajánlott).\n- Telepítés után a `node` és `npm` (Node Package Manager) parancsok elérhetővé válnak.\n\n## 3. Egyszerű Node.js alkalmazás\n\n```js\n// hello.js\nconsole.log('Hello, Node.js!');\n```\n\nA futtatás terminálban:\n```bash\nnode hello.js\n```\n\n## 4. NPM alapok\n\n- Az NPM a Node.js csomagkezelője, amellyel külső csomagokat tudsz telepíteni és kezelni.\n- Új projekt inicializálása:\n```bash\nnpm init -y\n```\n- Csomag telepítése:\n```bash\nnpm install express\n```\n\n## 5. Aszinkronitás Node.js-ben\n\n- Node.js I/O műveletei (fájlműveletek, hálózati kérések) alapból aszinkronok.\n- Callback-eket, Promise-okat vagy async/await-et használhatunk.\n\n## 6. Alap HTTP szerver Node.js-ben\n\n```js\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('Hello from Node.js server!');\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});\n```\n\n## 7. Fontos Node.js modulok\n\n- `fs`: fájlkezelés\n- `path`: fájl- és útvonalkezelés\n- `http` és `https`: szerverek készítése\n- `events`: eseménykezelés\n\n## 8. Fejlesztői eszközök\n\n- Nodemon: automatikus újraindítás fejlesztés közben\n```bash\nnpm install -g nodemon\nnodemon hello.js\n```\n\n---\n\n## Összefoglalás\n\n- A Node.js lehetővé teszi a JavaScript használatát szerveroldalon.\n- A Node.js eseményvezérelt és aszinkron működésű.\n- Az NPM segítségével könnyen kezelhetjük a függőségeket.\n- Egyszerű HTTP szervert pár sor kóddal létrehozhatunk.\n\n---\n\n### Példa kód\n\n```js\n// hello.js\nconsole.log('Hello, Node.js!');\n```\n\n---\n\n## További források\n\n- [Node.js hivatalos dokumentáció](https://nodejs.org/en/docs/)\n- [NPM dokumentáció](https://docs.npmjs.com/)\n\n",
  "keyPoints": [
    "Node.js egy JavaScript futtatókörnyezet szerveroldalra.",
    "A V8 motoron fut és eseményvezérelt, aszinkron modellt használ.",
    "NPM segítségével csomagokat telepíthetünk és kezelhetünk.",
    "Egyszerű HTTP szerver gyorsan létrehozható Node.js-ben.",
    "Nodemon fejlesztési eszköz az automatikus újraindításhoz."
  ]
},
{
  "id": 34,
  "title": "JavaScript Build eszközök (Webpack, Babel rövid áttekintés)",
  "content": "Ebben a leckében áttekintjük a JavaScript build eszközök alapjait, különösen a Webpack és Babel használatát, amelyek segítenek a modern JavaScript kód hatékony fejlesztésében és futtatásában.\n\n---\n\n## 1. Miért van szükség build eszközökre?\n\n- A modern JavaScript fejlesztés során sok fájlt, modult használunk, amit össze kell csomagolni.\n- Régebbi böngészők nem támogatják az újabb nyelvi funkciókat, ezért szükséges a kód átalakítása (transpile).\n- Build eszközök segítenek CSS, képek és egyéb erőforrások kezelésében is.\n\n## 2. Webpack\n\n- Webpack egy modulcsomagoló (module bundler), amely összefűzi a projekt különböző moduljait egy vagy több fájlba.\n- Támogatja a JavaScript, CSS, képek, fontok és más fájlok importálását.\n- Konfigurálható, pluginokkal és loader-ekkel bővíthető.\n\n### Alapvető Webpack példa\n\n```js\n// webpack.config.js\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: __dirname + '/dist'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader'\n        }\n      }\n    ]\n  }\n};\n```\n\n- A `entry` az induló fájl.\n- Az `output` a kimeneti fájl és hely.\n- A `module.rules` résznél adhatjuk meg, hogy a `.js` fájlokat a Babel loader segítségével dolgozza fel.\n\n## 3. Babel\n\n- Babel egy JavaScript transpiler, amely a modern ES6+ kódot kompatibilissé alakítja régebbi böngészők számára.\n- Lehetővé teszi az új nyelvi funkciók használatát anélkül, hogy a böngésző támogatottsága korlátozna.\n\n### Babel használata\n\n- Telepítés:\n```bash\nnpm install --save-dev @babel/core @babel/preset-env babel-loader\n```\n- Konfiguráció (`.babelrc` vagy `babel.config.json`):\n\n```json\n{\n  \"presets\": [\"@babel/preset-env\"]\n}\n```\n\nEz azt jelenti, hogy a Babel az aktuális környezethez igazítja a kódot.\n\n## 4. Build folyamat\n\n- A fejlesztő írja a modern JavaScript kódot (ES6+).\n- A Webpack összefűzi a fájlokat és a Babel segítségével átalakítja a régebbi böngészők számára kompatibilis kódra.\n- Az eredmény egy vagy több kész, optimalizált JavaScript fájl, amit a böngésző be tud tölteni.\n\n## 5. Egyéb népszerű build eszközök\n\n- Parcel: egyszerűbb konfiguráció, gyors indulás.\n- Rollup: főként könyvtárak készítéséhez ajánlott.\n\n---\n\n## Összefoglalás\n\n- A Webpack és Babel kulcsfontosságú eszközök a modern JavaScript fejlesztésben.\n- Segítenek kezelni a modulokat és biztosítják a kód kompatibilitását.\n- Használatuk megkönnyíti a fejlesztést és javítja az alkalmazás teljesítményét.\n\n---\n\n### Példa parancsok\n\n```bash\nnpm install --save-dev webpack webpack-cli babel-loader @babel/core @babel/preset-env\nnpx webpack --config webpack.config.js\n```\n\n---\n\n## További források\n\n- [Webpack hivatalos oldal](https://webpack.js.org/)\n- [Babel hivatalos oldal](https://babeljs.io/)\n",
  "keyPoints": [
    "A build eszközök segítenek a modulok összevonásában és kód átalakításában.",
    "Webpack egy modulcsomagoló, amely kezel minden típusú fájlt egy projektben.",
    "Babel átalakítja a modern JavaScript kódot régebbi böngészők számára kompatibilissé.",
    "A két eszköz gyakran együtt használatos a hatékony fejlesztés érdekében.",
    "Alternatív build eszközök: Parcel, Rollup."
  ]
},
{
  "id": 35,
  "title": "Frontend frameworkök alapjai (React, Angular, Vue rövid áttekintés)",
  "content": "Ebben a leckében megismerkedünk a három legnépszerűbb frontend JavaScript frameworkkel: React, Angular és Vue. Röviden áttekintjük, miért hasznosak, miben különböznek, és mikor érdemes használni őket.\n\n---\n\n## 1. Mi az a frontend framework?\n\n- Segít összetett felhasználói felületek hatékony, újrafelhasználható komponensekre bontott fejlesztésében.\n- Kezeli az állapotokat, eseményeket, és dinamikus DOM változásokat.\n\n## 2. React\n\n- Fejlesztette a Facebook.\n- Komponens-alapú, deklaratív könyvtár.\n- JSX használata: JavaScript + HTML-szerű szintaxis egy fájlban.\n- Nagy közösség, sok kiegészítő könyvtár (pl. React Router, Redux).\n- Előnyök:\n  - Nagy szabadság, könnyű integrálni más könyvtárakkal.\n  - Egyszerű az egyirányú adatáramlás.\n- Hátrányok:\n  - Csak a view réteget kezeli, ezért sok esetben extra könyvtárakat kell választani állapotkezeléshez, routinghoz.\n\n## 3. Angular\n\n- Fejlesztette a Google.\n- Komplett, teljes körű keretrendszer.\n- TypeScript alapú, amely erős típusosságot biztosít.\n- Beépített eszközök: routing, formkezelés, HTTP kliens, dependency injection.\n- Előnyök:\n  - Nagy projekt esetén előnyös, mert „mindent egyben” megoldás.\n  - Strukturált, erős szabályozottság.\n- Hátrányok:\n  - Meredekebb tanulási görbe.\n  - Nagyobb súly, komplexitás.\n\n## 4. Vue.js\n\n- Fejlesztette Evan You.\n- Könnyen tanulható, progresszív framework.\n- Komponens-alapú, hasonló a Reacthez, de HTML template-eket használ.\n- Jó egyensúly a funkcionalitás és egyszerűség között.\n- Előnyök:\n  - Kisebb projektekhez gyorsan alkalmazható.\n  - Jó dokumentáció, egyszerű integráció meglévő oldalakba.\n- Hátrányok:\n  - Kisebb közösség, mint React vagy Angular.\n\n## 5. Összehasonlítás röviden\n\n| Tulajdonság          | React              | Angular             | Vue                 |\n|----------------------|--------------------|---------------------|---------------------|\n| Fejlesztő            | Facebook           | Google              | Evan You            |\n| Nyelv                | JavaScript + JSX    | TypeScript          | JavaScript + Template|\n| Tanulási görbe       | Mérsékelt           | Meredek             | Kicsi               |\n| Teljesség            | Könyvtár           | Komplett keretrendszer| Progresszív keretrendszer |\n| Közösség             | Nagy               | Nagy                | Közepes             |\n\n---\n\n## Mikor melyiket válasszuk?\n\n- Ha teljes körű megoldás kell, és TypeScript-et használsz: Angular.\n- Ha rugalmas megoldást keresel nagy közösséggel, vagy React ökoszisztéma fontos: React.\n- Ha egyszerű, gyors indulás és könnyű tanulás a cél, Vue.\n\n---\n\n## További források\n\n- [React hivatalos oldal](https://reactjs.org/)\n- [Angular hivatalos oldal](https://angular.io/)\n- [Vue hivatalos oldal](https://vuejs.org/)\n\n---\n\n### Összefoglalás\n\nFrontend frameworkök jelentősen megkönnyítik a modern webfejlesztést azáltal, hogy komponens-alapú fejlesztést, állapotkezelést és egyéb hasznos funkciókat kínálnak. A választás a projekt igényeitől, fejlesztői preferenciáktól és a tanulási görbétől függ.",
  "keyPoints": [
    "React: komponens-alapú, JSX, rugalmas, nagy közösség.",
    "Angular: teljes körű keretrendszer, TypeScript alapú, meredek tanulási görbe.",
    "Vue: könnyen tanulható, progresszív, egyszerű integráció meglévő projektekhez.",
    "Mindhárom népszerű, eltérő erősségekkel és használati esetekkel.",
    "A választás a projekt méretétől és fejlesztői preferenciáktól függ."
  ]
},
{
  "id": 36,
  "title": "Progressive Web App (PWA) JavaScript oldali része",
  "content": "Ebben a leckében a Progressive Web App (PWA) JavaScript-es megvalósításának alapjaival ismerkedünk meg. A PWA-k a webalkalmazások új generációja, amelyek natív app-szerű élményt nyújtanak, offline működéssel, push értesítésekkel és gyors betöltéssel.\n\n---\n\n## 1. Mi az a PWA?\n\n- Webalkalmazás, amely a modern webes technológiákat használja natív app-szerű élményért.\n- Elérhető offline, telepíthető, push értesítéseket képes kezelni.\n\n## 2. Service Worker\n\n- A PWA egyik kulcsfontosságú eleme egy JavaScript fájl, amely a böngésző és a hálózat között helyezkedik el.\n- Képes cache-elni az oldalakat és adatokat, így offline működést biztosít.\n- Regisztrálása JavaScript-ben:\n\n```js\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('/service-worker.js')\n      .then(registration => {\n        console.log('Service Worker regisztrálva:', registration);\n      })\n      .catch(error => {\n        console.error('Service Worker regisztráció sikertelen:', error);\n      });\n  });\n}\n```\n\n- A service worker fájlban eseménykezelők vannak, pl. fetch esemény a hálózati kérések kezelésére.\n\n## 3. Cache kezelése Service Workerben\n\n- Fontos az offline élményhez.\n- Példa egyszerű cache-elésre:\n\n```js\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open('my-cache-v1').then(cache => {\n      return cache.addAll([\n        '/',\n        '/index.html',\n        '/styles.css',\n        '/app.js',\n      ]);\n    })\n  );\n});\n\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request).then(response => {\n      return response || fetch(event.request);\n    })\n  );\n});\n```\n\n## 4. Web App Manifest\n\n- Egy JSON fájl, amely megadja az alkalmazás nevét, ikonjait, kezdőképernyői beállításait.\n- JavaScript-ből nincs közvetlen kezelése, de a manifest-re hivatkozni kell a HTML-ben:\n\n```html\n<link rel=\"manifest\" href=\"/manifest.json\">\n```\n\n## 5. Push értesítések (alapok)\n\n- A Service Worker segítségével lehet fogadni push értesítéseket.\n- Push API használata regisztráció után, de ez haladó téma, itt csak megemlítjük.\n\n## 6. Offline események kezelése\n\n- Például az online/offline állapot figyelése:\n\n```js\nwindow.addEventListener('online', () => {\n  console.log('Az alkalmazás online állapotba került');\n});\n\nwindow.addEventListener('offline', () => {\n  console.log('Az alkalmazás offline állapotba került');\n});\n```\n\n---\n\n### Összefoglalás\n\nA PWA-k modern webalkalmazások, melyek JavaScript segítségével offline működést, gyorsaságot és natív app-szerű élményt nyújtanak. A Service Worker a PWA kulcsa, amely cache-eléssel és hálózati kérés kezelésével teszi lehetővé az offline használatot. A Web App Manifest segíti a telepítést és megjelenést, míg a Push API a kommunikációt teszi interaktívabbá.\n\n---\n\n### Hasznos források\n- https://web.dev/progressive-web-apps/\n- https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\n- https://developer.mozilla.org/en-US/docs/Web/Manifest\n",
  "keyPoints": [
    "Service Worker regisztrálása JavaScript-ben az offline működésért.",
    "Cache-elés kezelése a Service Workerben a gyorsabb betöltéshez és offline használathoz.",
    "Web App Manifest fájl konfigurációja a telepítéshez és megjelenéshez.",
    "Online/offline események figyelése a JavaScript-ben.",
    "Push értesítések lehetősége Service Worker segítségével (alapszinten)."
  ]
},
{
  "id": 37,
  "title": "JavaScript optimalizáció és teljesítmény javítás",
  "content": "Ebben a leckében áttekintjük a JavaScript optimalizáció legfontosabb szempontjait és technikáit, amelyekkel javítható a kód futási sebessége és a weboldal teljesítménye.\n\n---\n\n## 1. Minimalizálás és tömörítés\n\n- A kód méretének csökkentése kisebb letöltési időt eredményez.\n- Eszközök: UglifyJS, Terser, Babel minify.\n\n## 2. Debouncing és throttling\n\n- Eseménykezelőkre alkalmazva (pl. scroll, resize), hogy kevesebb hívás történjen rövid idő alatt.\n- Debounce: a függvény csak akkor fut le, ha a trigger nem ismétlődik egy adott időn belül.\n- Throttle: a függvény legfeljebb egy adott időközönként fut le.\n\n## 3. Aszinkron műveletek és requestAnimationFrame\n\n- Ne blokkoljuk a fő szálat hosszú műveletekkel.\n- Animációkhoz használjuk requestAnimationFrame-et.\n\n## 4. Kód optimalizálása\n\n- Változók deklarálása a legszűkebb scope-ban.\n- Felesleges globális változók kerülése.\n- Hatékony ciklusok használata (pl. for helyett while lehet gyorsabb bizonyos helyzetekben).\n- Memóriahasználat optimalizálása: ne tartsunk fent fölösleges referenciákat.\n\n## 5. DOM manipuláció minimalizálása\n\n- Több DOM művelet helyett csoportosítsuk a változtatásokat.\n- Használjunk DocumentFragment-et vagy virtuális DOM megoldásokat.\n\n## 6. Event delegation alkalmazása\n\n- Sok hasonló eseménykezelő helyett egy közös szülőn kezelt esemény.\n\n## 7. Lazy loading és dinamikus import\n\n- Csak akkor töltsük be a kódot vagy adatot, amikor szükséges.\n- Dinamikus import() használata moduloknál.\n\n## 8. Profilozás és mérés\n\n- Használjuk a böngészők DevTools profilozó eszközeit.\n- Azonosítsuk a bottleneckeket, majd célozzuk meg a leglassabb részeket.\n\n---\n\n### Összefoglalás\n\nA JavaScript optimalizáció kulcsa a hatékony kódírás, a felesleges műveletek elkerülése, és a modern aszinkron technikák alkalmazása. Profilozással és tudatos fejlesztéssel jelentősen javítható a weboldal teljesítménye és felhasználói élménye.\n\n---\n\n### Hasznos források\n- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Performance_best_practices\n- https://web.dev/optimize-javascript/\n- https://css-tricks.com/debouncing-throttling-explained-examples/\n",
  "keyPoints": [
    "Kód minimalizálása és tömörítése a gyorsabb betöltésért.",
    "Debouncing és throttling használata eseménykezeléshez.",
    "Aszinkron műveletek alkalmazása a fő szál blokkolásának elkerülésére.",
    "DOM manipuláció csökkentése és optimalizálása.",
    "Profilozás és mérés a teljesítmény problémák azonosításához."
  ]
},
{
  "id": 38,
  "title": "Biztonsági alapelvek JavaScript fejlesztésben (XSS, CSP stb.)",
  "content": "Ebben a leckében áttekintjük a JavaScript fejlesztés során fontos biztonsági alapelveket, különös tekintettel a Cross-Site Scripting (XSS) támadásokra, a Content Security Policy (CSP) használatára, valamint más alapvető védekezési módszerekre.\n\n---\n\n## 1. Cross-Site Scripting (XSS) alapjai\n\n- XSS egy olyan támadási forma, amikor rosszindulatú kód kerül beillesztésre egy weboldalba, és más felhasználók böngészőjében fut le.\n- Ezzel a támadó például cookie-kat, session adatokat vagy érzékeny információkat lophat el.\n\n### Példa XSS-re:\n\n```html\n<div id=\"output\"></div>\n<script>\n  const userInput = '<img src=x onerror=alert(\"XSS\")>';\n  document.getElementById('output').innerHTML = userInput; // veszélyes\n</script>\n```\n\n## 2. Védekezés XSS ellen\n\n- Soha ne illesszünk be felhasználói adatot közvetlenül `innerHTML`-be.\n- Használjunk biztonságos módszereket, mint `textContent` vagy szigorú szűrést, kódolást.\n- Input validáció és output encoding elengedhetetlen.\n\n## 3. Content Security Policy (CSP)\n\n- CSP egy HTTP fejléchez adott szabályrendszer, amely korlátozza, hogy honnan tölthető be és milyen kód futtatható a weboldalon.\n- Segít megelőzni XSS és más támadásokat.\n\n### Példa egyszerű CSP-re:\n\n```http\nContent-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com;\n```\n\n## 4. Egyéb biztonsági alapelvek\n\n- Használj HTTPS-t a kommunikáció titkosításához.\n- Kerüld a veszélyes eval() függvény használatát.\n- Óvakodj az érzékeny adatokat tárolni vagy kezelni kliens oldalon.\n- Frissítsd rendszeresen a használt könyvtárakat, keretrendszereket.\n\n## 5. Összefoglalás\n\n- Mindig ellenőrizd és szűrd a felhasználói bemeneteket.\n- Használj biztonsági fejléceket, például CSP-t.\n- Kerüld a dinamikus kód futtatását.\n- Figyelj a HTTPS és a könyvtárak frissítésére.\n\n---\n\n### Hasznos források\n- https://owasp.org/www-community/attacks/xss/\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\n- https://developer.mozilla.org/en-US/docs/Web/Security\n",
  "keyPoints": [
    "XSS támadások megelőzése input validációval és output encodinggal.",
    "Soha ne használj `innerHTML` felhasználói adat közvetlen beillesztésére, inkább `textContent`-et.",
    "Content Security Policy (CSP) használata a script és resource betöltések korlátozására.",
    "HTTPS használata és a `eval()` kerülése biztonsági okokból.",
    "Rendszeres frissítés és biztonságtudatos fejlesztés elengedhetetlen."
  ]
}

  ]}